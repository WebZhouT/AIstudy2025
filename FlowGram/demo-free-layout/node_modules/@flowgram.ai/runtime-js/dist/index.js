"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  TaskCancelAPI: () => TaskCancelAPI,
  TaskReportAPI: () => TaskReportAPI,
  TaskResultAPI: () => TaskResultAPI,
  TaskRunAPI: () => TaskRunAPI,
  WorkflowRuntimeAPIs: () => WorkflowRuntimeAPIs
});
module.exports = __toCommonJS(src_exports);

// ../interface/dist/esm/index.js
var import_zod = __toESM(require("zod"));
var import_zod2 = __toESM(require("zod"));
var import_zod3 = __toESM(require("zod"));
var import_zod4 = __toESM(require("zod"));
var import_zod5 = __toESM(require("zod"));
var import_zod6 = __toESM(require("zod"));
var import_zod7 = __toESM(require("zod"));
var FlowGramAPIName = /* @__PURE__ */ ((FlowGramAPIName2) => {
  FlowGramAPIName2["ServerInfo"] = "ServerInfo";
  FlowGramAPIName2["TaskRun"] = "TaskRun";
  FlowGramAPIName2["TaskReport"] = "TaskReport";
  FlowGramAPIName2["TaskResult"] = "TaskResult";
  FlowGramAPIName2["TaskCancel"] = "TaskCancel";
  FlowGramAPIName2["Validation"] = "Validation";
  return FlowGramAPIName2;
})(FlowGramAPIName || {});
var ValidationDefine = {
  name: "Validation",
  method: "POST",
  path: "/validation",
  module: "Validation",
  schema: {
    input: import_zod.default.object({
      schema: import_zod.default.string()
    }),
    output: import_zod.default.object({
      valid: import_zod.default.boolean(),
      nodeErrors: import_zod.default.array(
        import_zod.default.object({
          message: import_zod.default.string(),
          nodeID: import_zod.default.string()
        })
      ),
      edgeErrors: import_zod.default.array(
        import_zod.default.object({
          message: import_zod.default.string(),
          edge: import_zod.default.object({
            sourceNodeID: import_zod.default.string(),
            targetNodeID: import_zod.default.string(),
            sourcePortID: import_zod.default.string().optional(),
            targetPortID: import_zod.default.string().optional()
          })
        })
      )
    })
  }
};
var WorkflowIOZodSchema = import_zod3.default.record(import_zod3.default.string(), import_zod3.default.any());
var WorkflowSnapshotZodSchema = import_zod3.default.object({
  id: import_zod3.default.string(),
  nodeID: import_zod3.default.string(),
  inputs: WorkflowIOZodSchema,
  outputs: WorkflowIOZodSchema.optional(),
  data: WorkflowIOZodSchema,
  branch: import_zod3.default.string().optional()
});
var WorkflowStatusZodShape = {
  status: import_zod3.default.string(),
  terminated: import_zod3.default.boolean(),
  startTime: import_zod3.default.number(),
  endTime: import_zod3.default.number().optional(),
  timeCost: import_zod3.default.number()
};
var WorkflowStatusZodSchema = import_zod3.default.object(WorkflowStatusZodShape);
var WorkflowZodSchema = {
  Inputs: WorkflowIOZodSchema,
  Outputs: WorkflowIOZodSchema,
  Status: WorkflowStatusZodSchema,
  Snapshot: WorkflowSnapshotZodSchema,
  NodeReport: import_zod3.default.object({
    id: import_zod3.default.string(),
    ...WorkflowStatusZodShape,
    snapshots: import_zod3.default.array(WorkflowSnapshotZodSchema)
  })
};
var TaskRunDefine = {
  name: "TaskRun",
  method: "POST",
  path: "/task/run",
  module: "Task",
  schema: {
    input: import_zod2.default.object({
      schema: import_zod2.default.string(),
      inputs: WorkflowZodSchema.Inputs
    }),
    output: import_zod2.default.object({
      taskID: import_zod2.default.string()
    })
  }
};
var TaskResultDefine = {
  name: "TaskResult",
  method: "GET",
  path: "/task/result",
  module: "Task",
  schema: {
    input: import_zod4.default.object({
      taskID: import_zod4.default.string()
    }),
    output: WorkflowZodSchema.Outputs
  }
};
var TaskReportDefine = {
  name: "TaskReport",
  method: "GET",
  path: "/task/report",
  module: "Task",
  schema: {
    input: import_zod5.default.object({
      taskID: import_zod5.default.string()
    }),
    output: import_zod5.default.object({
      id: import_zod5.default.string(),
      inputs: WorkflowZodSchema.Inputs,
      outputs: WorkflowZodSchema.Outputs,
      workflowStatus: WorkflowZodSchema.Status,
      reports: import_zod5.default.record(import_zod5.default.string(), WorkflowZodSchema.NodeReport)
    })
  }
};
var TaskCancelDefine = {
  name: "TaskCancel",
  method: "PUT",
  path: "/task/cancel",
  module: "Task",
  schema: {
    input: import_zod6.default.object({
      taskID: import_zod6.default.string()
    }),
    output: import_zod6.default.object({
      success: import_zod6.default.boolean()
    })
  }
};
var ServerInfoDefine = {
  name: "ServerInfo",
  method: "GET",
  path: "/info",
  module: "Info",
  schema: {
    input: import_zod7.default.undefined(),
    output: import_zod7.default.object({
      name: import_zod7.default.string(),
      runtime: import_zod7.default.string(),
      version: import_zod7.default.string(),
      time: import_zod7.default.string()
    })
  }
};
var FlowGramAPIs = {
  [
    "ServerInfo"
    /* ServerInfo */
  ]: ServerInfoDefine,
  [
    "TaskRun"
    /* TaskRun */
  ]: TaskRunDefine,
  [
    "TaskReport"
    /* TaskReport */
  ]: TaskReportDefine,
  [
    "TaskResult"
    /* TaskResult */
  ]: TaskResultDefine,
  [
    "TaskCancel"
    /* TaskCancel */
  ]: TaskCancelDefine,
  [
    "Validation"
    /* Validation */
  ]: ValidationDefine
};
var FlowGramAPINames = Object.keys(FlowGramAPIs);
var WorkflowPortType = /* @__PURE__ */ ((WorkflowPortType2) => {
  WorkflowPortType2["Input"] = "input";
  WorkflowPortType2["Output"] = "output";
  return WorkflowPortType2;
})(WorkflowPortType || {});
var WorkflowVariableType = /* @__PURE__ */ ((WorkflowVariableType2) => {
  WorkflowVariableType2["String"] = "string";
  WorkflowVariableType2["Integer"] = "integer";
  WorkflowVariableType2["Number"] = "number";
  WorkflowVariableType2["Boolean"] = "boolean";
  WorkflowVariableType2["Object"] = "object";
  WorkflowVariableType2["Array"] = "array";
  WorkflowVariableType2["Null"] = "null";
  return WorkflowVariableType2;
})(WorkflowVariableType || {});
var FlowGramNode = /* @__PURE__ */ ((FlowGramNode22) => {
  FlowGramNode22["Root"] = "root";
  FlowGramNode22["Start"] = "start";
  FlowGramNode22["End"] = "end";
  FlowGramNode22["LLM"] = "llm";
  FlowGramNode22["code"] = "code";
  FlowGramNode22["Condition"] = "condition";
  FlowGramNode22["Loop"] = "loop";
  FlowGramNode22["Comment"] = "comment";
  FlowGramNode22["Group"] = "group";
  return FlowGramNode22;
})(FlowGramNode || {});
var IEngine = Symbol.for("Engine");
var IExecutor = Symbol.for("Executor");
var WorkflowStatus = /* @__PURE__ */ ((WorkflowStatus2) => {
  WorkflowStatus2["Pending"] = "pending";
  WorkflowStatus2["Processing"] = "processing";
  WorkflowStatus2["Succeeded"] = "succeeded";
  WorkflowStatus2["Failed"] = "failed";
  WorkflowStatus2["Canceled"] = "canceled";
  return WorkflowStatus2;
})(WorkflowStatus || {});
var IValidation = Symbol.for("Validation");

// src/nodes/start/index.ts
var StartExecutor = class {
  constructor() {
    this.type = FlowGramNode.Start;
  }
  async execute(context) {
    return {
      outputs: context.runtime.ioCenter.inputs
    };
  }
};

// src/nodes/loop/index.ts
var import_lodash_es = require("lodash-es");
var LoopExecutor = class {
  constructor() {
    this.type = FlowGramNode.Loop;
  }
  async execute(context) {
    const loopNodeID = context.node.id;
    const loopArrayResult = context.runtime.state.parseRef(context.node.data.batchFor);
    this.checkLoopArray(loopArrayResult);
    const loopArray = loopArrayResult.value;
    const itemsType = loopArrayResult.itemsType;
    const engine = context.container.get(IEngine);
    const subNodes = context.node.children;
    const startSubNodes = subNodes.filter((node) => node.prev.length === 0);
    if (loopArray.length === 0 || startSubNodes.length === 0) {
      return {
        outputs: {}
      };
    }
    for (let i = 0; i < loopArray.length; i++) {
      const loopItem = loopArray[i];
      const subContext = context.runtime.sub();
      subContext.variableStore.setVariable({
        nodeID: `${loopNodeID}_locals`,
        key: "item",
        type: itemsType,
        value: loopItem
      });
      await Promise.all(
        startSubNodes.map(
          (node) => engine.executeNode({
            context: subContext,
            node
          })
        )
      );
    }
    return {
      outputs: {}
    };
  }
  checkLoopArray(loopArrayResult) {
    const loopArray = loopArrayResult?.value;
    if (!loopArray || (0, import_lodash_es.isNil)(loopArray) || !Array.isArray(loopArray)) {
      throw new Error("batchFor is required");
    }
    const loopArrayType = loopArrayResult.type;
    if (loopArrayType !== WorkflowVariableType.Array) {
      throw new Error("batchFor must be an array");
    }
    const loopArrayItemType = loopArrayResult.itemsType;
    if ((0, import_lodash_es.isNil)(loopArrayItemType)) {
      throw new Error("batchFor items must be array items");
    }
  }
};

// src/nodes/llm/index.ts
var import_lodash_es2 = require("lodash-es");
var import_openai = require("@langchain/openai");
var import_messages = require("@langchain/core/messages");
var LLMExecutor = class {
  constructor() {
    this.type = FlowGramNode.LLM;
  }
  async execute(context) {
    const inputs = context.inputs;
    this.checkInputs(inputs);
    const { modelName, temperature, apiKey, apiHost, systemPrompt, prompt } = inputs;
    const model = new import_openai.ChatOpenAI({
      modelName,
      temperature,
      apiKey,
      configuration: {
        baseURL: apiHost
      }
    });
    const messages = [];
    if (systemPrompt) {
      messages.push(new import_messages.SystemMessage(systemPrompt));
    }
    messages.push(new import_messages.HumanMessage(prompt));
    const apiMessage = await model.invoke(messages);
    const result = apiMessage.content;
    return {
      outputs: {
        result
      }
    };
  }
  checkInputs(inputs) {
    const { modelName, temperature, apiKey, apiHost, prompt } = inputs;
    const missingInputs = [];
    if ((0, import_lodash_es2.isNil)(modelName)) missingInputs.push("modelName");
    if ((0, import_lodash_es2.isNil)(temperature)) missingInputs.push("temperature");
    if ((0, import_lodash_es2.isNil)(apiKey)) missingInputs.push("apiKey");
    if ((0, import_lodash_es2.isNil)(apiHost)) missingInputs.push("apiHost");
    if ((0, import_lodash_es2.isNil)(prompt)) missingInputs.push("prompt");
    if (missingInputs.length > 0) {
      throw new Error(`LLM node missing required inputs: ${missingInputs.join(", ")}`);
    }
  }
};

// src/nodes/end/index.ts
var EndExecutor = class {
  constructor() {
    this.type = FlowGramNode.End;
  }
  async execute(context) {
    context.runtime.ioCenter.setOutputs(context.inputs);
    return {
      outputs: context.inputs
    };
  }
};

// src/nodes/condition/index.ts
var import_lodash_es9 = require("lodash-es");

// src/nodes/condition/rules.ts
var conditionRules = {
  [WorkflowVariableType.String]: {
    ["eq" /* EQ */]: WorkflowVariableType.String,
    ["neq" /* NEQ */]: WorkflowVariableType.String,
    ["contains" /* CONTAINS */]: WorkflowVariableType.String,
    ["not_contains" /* NOT_CONTAINS */]: WorkflowVariableType.String,
    ["in" /* IN */]: WorkflowVariableType.Array,
    ["nin" /* NIN */]: WorkflowVariableType.Array,
    ["is_empty" /* IS_EMPTY */]: WorkflowVariableType.String,
    ["is_not_empty" /* IS_NOT_EMPTY */]: WorkflowVariableType.String
  },
  [WorkflowVariableType.Number]: {
    ["eq" /* EQ */]: WorkflowVariableType.Number,
    ["neq" /* NEQ */]: WorkflowVariableType.Number,
    ["gt" /* GT */]: WorkflowVariableType.Number,
    ["gte" /* GTE */]: WorkflowVariableType.Number,
    ["lt" /* LT */]: WorkflowVariableType.Number,
    ["lte" /* LTE */]: WorkflowVariableType.Number,
    ["in" /* IN */]: WorkflowVariableType.Array,
    ["nin" /* NIN */]: WorkflowVariableType.Array,
    ["is_empty" /* IS_EMPTY */]: WorkflowVariableType.Null,
    ["is_not_empty" /* IS_NOT_EMPTY */]: WorkflowVariableType.Null
  },
  [WorkflowVariableType.Integer]: {
    ["eq" /* EQ */]: WorkflowVariableType.Integer,
    ["neq" /* NEQ */]: WorkflowVariableType.Integer,
    ["gt" /* GT */]: WorkflowVariableType.Integer,
    ["gte" /* GTE */]: WorkflowVariableType.Integer,
    ["lt" /* LT */]: WorkflowVariableType.Integer,
    ["lte" /* LTE */]: WorkflowVariableType.Integer,
    ["in" /* IN */]: WorkflowVariableType.Array,
    ["nin" /* NIN */]: WorkflowVariableType.Array,
    ["is_empty" /* IS_EMPTY */]: WorkflowVariableType.Null,
    ["is_not_empty" /* IS_NOT_EMPTY */]: WorkflowVariableType.Null
  },
  [WorkflowVariableType.Boolean]: {
    ["eq" /* EQ */]: WorkflowVariableType.Boolean,
    ["neq" /* NEQ */]: WorkflowVariableType.Boolean,
    ["is_true" /* IS_TRUE */]: WorkflowVariableType.Null,
    ["is_false" /* IS_FALSE */]: WorkflowVariableType.Null,
    ["in" /* IN */]: WorkflowVariableType.Array,
    ["nin" /* NIN */]: WorkflowVariableType.Array,
    ["is_empty" /* IS_EMPTY */]: WorkflowVariableType.Null,
    ["is_not_empty" /* IS_NOT_EMPTY */]: WorkflowVariableType.Null
  },
  [WorkflowVariableType.Object]: {
    ["is_empty" /* IS_EMPTY */]: WorkflowVariableType.Null,
    ["is_not_empty" /* IS_NOT_EMPTY */]: WorkflowVariableType.Null
  },
  [WorkflowVariableType.Array]: {
    ["is_empty" /* IS_EMPTY */]: WorkflowVariableType.Null,
    ["is_not_empty" /* IS_NOT_EMPTY */]: WorkflowVariableType.Null
  },
  [WorkflowVariableType.Null]: {
    ["eq" /* EQ */]: WorkflowVariableType.Null,
    ["is_empty" /* IS_EMPTY */]: WorkflowVariableType.Null,
    ["is_not_empty" /* IS_NOT_EMPTY */]: WorkflowVariableType.Null
  }
};

// src/nodes/condition/handlers/string.ts
var import_lodash_es3 = require("lodash-es");
var conditionStringHandler = (condition) => {
  const { operator } = condition;
  const leftValue = condition.leftValue;
  if (operator === "eq" /* EQ */) {
    const rightValue = condition.rightValue;
    return leftValue === rightValue;
  }
  if (operator === "neq" /* NEQ */) {
    const rightValue = condition.rightValue;
    return leftValue !== rightValue;
  }
  if (operator === "contains" /* CONTAINS */) {
    const rightValue = condition.rightValue;
    return leftValue.includes(rightValue);
  }
  if (operator === "not_contains" /* NOT_CONTAINS */) {
    const rightValue = condition.rightValue;
    return !leftValue.includes(rightValue);
  }
  if (operator === "in" /* IN */) {
    const rightValue = condition.rightValue;
    return rightValue.includes(leftValue);
  }
  if (operator === "nin" /* NIN */) {
    const rightValue = condition.rightValue;
    return !rightValue.includes(leftValue);
  }
  if (operator === "is_empty" /* IS_EMPTY */) {
    return (0, import_lodash_es3.isNil)(leftValue);
  }
  if (operator === "is_not_empty" /* IS_NOT_EMPTY */) {
    return !(0, import_lodash_es3.isNil)(leftValue);
  }
  return false;
};

// src/nodes/condition/handlers/object.ts
var import_lodash_es4 = require("lodash-es");
var conditionObjectHandler = (condition) => {
  const { operator } = condition;
  const leftValue = condition.leftValue;
  if (operator === "is_empty" /* IS_EMPTY */) {
    return (0, import_lodash_es4.isNil)(leftValue);
  }
  if (operator === "is_not_empty" /* IS_NOT_EMPTY */) {
    return !(0, import_lodash_es4.isNil)(leftValue);
  }
  return false;
};

// src/nodes/condition/handlers/number.ts
var import_lodash_es5 = require("lodash-es");
var conditionNumberHandler = (condition) => {
  const { operator } = condition;
  const leftValue = condition.leftValue;
  if (operator === "eq" /* EQ */) {
    const rightValue = condition.rightValue;
    return leftValue === rightValue;
  }
  if (operator === "neq" /* NEQ */) {
    const rightValue = condition.rightValue;
    return leftValue !== rightValue;
  }
  if (operator === "gt" /* GT */) {
    const rightValue = condition.rightValue;
    return leftValue > rightValue;
  }
  if (operator === "gte" /* GTE */) {
    const rightValue = condition.rightValue;
    return leftValue >= rightValue;
  }
  if (operator === "lt" /* LT */) {
    const rightValue = condition.rightValue;
    return leftValue < rightValue;
  }
  if (operator === "lte" /* LTE */) {
    const rightValue = condition.rightValue;
    return leftValue <= rightValue;
  }
  if (operator === "in" /* IN */) {
    const rightValue = condition.rightValue;
    return rightValue.includes(leftValue);
  }
  if (operator === "nin" /* NIN */) {
    const rightValue = condition.rightValue;
    return !rightValue.includes(leftValue);
  }
  if (operator === "is_empty" /* IS_EMPTY */) {
    return (0, import_lodash_es5.isNil)(leftValue);
  }
  if (operator === "is_not_empty" /* IS_NOT_EMPTY */) {
    return !(0, import_lodash_es5.isNil)(leftValue);
  }
  return false;
};

// src/nodes/condition/handlers/null.ts
var import_lodash_es6 = require("lodash-es");
var conditionNullHandler = (condition) => {
  const { operator } = condition;
  const leftValue = condition.leftValue;
  if (operator === "eq" /* EQ */) {
    return (0, import_lodash_es6.isNil)(leftValue) && (0, import_lodash_es6.isNil)(condition.rightValue);
  }
  if (operator === "is_empty" /* IS_EMPTY */) {
    return (0, import_lodash_es6.isNil)(leftValue);
  }
  if (operator === "is_not_empty" /* IS_NOT_EMPTY */) {
    return !(0, import_lodash_es6.isNil)(leftValue);
  }
  return false;
};

// src/nodes/condition/handlers/boolean.ts
var import_lodash_es7 = require("lodash-es");
var conditionBooleanHandler = (condition) => {
  const { operator } = condition;
  const leftValue = condition.leftValue;
  if (operator === "eq" /* EQ */) {
    const rightValue = condition.rightValue;
    return leftValue === rightValue;
  }
  if (operator === "neq" /* NEQ */) {
    const rightValue = condition.rightValue;
    return leftValue !== rightValue;
  }
  if (operator === "is_true" /* IS_TRUE */) {
    return leftValue === true;
  }
  if (operator === "is_false" /* IS_FALSE */) {
    return leftValue === false;
  }
  if (operator === "in" /* IN */) {
    const rightValue = condition.rightValue;
    return rightValue.includes(leftValue);
  }
  if (operator === "nin" /* NIN */) {
    const rightValue = condition.rightValue;
    return !rightValue.includes(leftValue);
  }
  if (operator === "is_empty" /* IS_EMPTY */) {
    return (0, import_lodash_es7.isNil)(leftValue);
  }
  if (operator === "is_not_empty" /* IS_NOT_EMPTY */) {
    return !(0, import_lodash_es7.isNil)(leftValue);
  }
  return false;
};

// src/nodes/condition/handlers/array.ts
var import_lodash_es8 = require("lodash-es");
var conditionArrayHandler = (condition) => {
  const { operator } = condition;
  const leftValue = condition.leftValue;
  if (operator === "is_empty" /* IS_EMPTY */) {
    return (0, import_lodash_es8.isNil)(leftValue);
  }
  if (operator === "is_not_empty" /* IS_NOT_EMPTY */) {
    return !(0, import_lodash_es8.isNil)(leftValue);
  }
  return false;
};

// src/nodes/condition/handlers/index.ts
var conditionHandlers = {
  [WorkflowVariableType.String]: conditionStringHandler,
  [WorkflowVariableType.Number]: conditionNumberHandler,
  [WorkflowVariableType.Integer]: conditionNumberHandler,
  [WorkflowVariableType.Boolean]: conditionBooleanHandler,
  [WorkflowVariableType.Object]: conditionObjectHandler,
  [WorkflowVariableType.Array]: conditionArrayHandler,
  [WorkflowVariableType.Null]: conditionNullHandler
};

// src/nodes/condition/index.ts
var ConditionExecutor = class {
  constructor() {
    this.type = FlowGramNode.Condition;
  }
  async execute(context) {
    const conditions = context.node.data?.conditions;
    if (!conditions) {
      return {
        outputs: {}
      };
    }
    const parsedConditions = conditions.map((item) => this.parseCondition(item, context)).filter((item) => this.checkCondition(item));
    const activatedCondition = parsedConditions.find((item) => this.handleCondition(item));
    if (!activatedCondition) {
      return {
        outputs: {}
      };
    }
    return {
      outputs: {},
      branch: activatedCondition.key
    };
  }
  parseCondition(item, context) {
    const { key, value } = item;
    const { left, operator, right } = value;
    const parsedLeft = context.runtime.state.parseRef(left);
    const leftValue = parsedLeft?.value ?? null;
    const leftType = parsedLeft?.type ?? WorkflowVariableType.Null;
    const parsedRight = Boolean(right) ? context.runtime.state.parseValue(right) : null;
    const rightValue = parsedRight?.value ?? null;
    const rightType = parsedRight?.type ?? WorkflowVariableType.Null;
    return {
      key,
      leftValue,
      leftType,
      rightValue,
      rightType,
      operator
    };
  }
  checkCondition(condition) {
    const rule = conditionRules[condition.leftType];
    if ((0, import_lodash_es9.isNil)(rule)) {
      throw new Error(`condition left type ${condition.leftType} is not supported`);
    }
    const ruleType = rule[condition.operator];
    if ((0, import_lodash_es9.isNil)(ruleType)) {
      throw new Error(`condition operator ${condition.operator} is not supported`);
    }
    if (ruleType !== condition.rightType) {
      return false;
    }
    return true;
  }
  handleCondition(condition) {
    const handler = conditionHandlers[condition.leftType];
    if (!handler) {
      throw new Error(`condition left type ${condition.leftType} is not supported`);
    }
    const isActive = handler(condition);
    return isActive;
  }
};

// src/nodes/index.ts
var WorkflowRuntimeNodeExecutors = [
  StartExecutor,
  EndExecutor,
  LLMExecutor,
  ConditionExecutor,
  LoopExecutor
];

// src/domain/validation/index.ts
var WorkflowRuntimeValidation = class {
  validate(schema) {
    return {
      valid: true
    };
  }
};

// src/domain/executor/index.ts
var WorkflowRuntimeExecutor = class {
  constructor(nodeExecutors) {
    this.nodeExecutors = /* @__PURE__ */ new Map();
    nodeExecutors.forEach((executor) => {
      this.register(new executor());
    });
  }
  register(executor) {
    this.nodeExecutors.set(executor.type, executor);
  }
  async execute(context) {
    const nodeType = context.node.type;
    const nodeExecutor = this.nodeExecutors.get(nodeType);
    if (!nodeExecutor) {
      throw new Error(`no executor found for node type ${nodeType}`);
    }
    const output = await nodeExecutor.execute(context);
    return output;
  }
};

// src/infrastructure/utils/uuid.ts
var import_uuid = require("uuid");
var uuid = import_uuid.v4;

// src/infrastructure/utils/runtime-type.ts
var WorkflowRuntimeType;
((WorkflowRuntimeType2) => {
  WorkflowRuntimeType2.getWorkflowType = (value) => {
    if (value === null || value === void 0) {
      return WorkflowVariableType.Null;
    }
    if (typeof value === "string") {
      return WorkflowVariableType.String;
    }
    if (typeof value === "boolean") {
      return WorkflowVariableType.Boolean;
    }
    if (typeof value === "number") {
      if (Number.isInteger(value)) {
        return WorkflowVariableType.Integer;
      }
      return WorkflowVariableType.Number;
    }
    if (Array.isArray(value)) {
      return WorkflowVariableType.Array;
    }
    if (typeof value === "object") {
      return WorkflowVariableType.Object;
    }
    return null;
  };
  WorkflowRuntimeType2.isMatchWorkflowType = (value, type) => {
    const workflowType = (0, WorkflowRuntimeType2.getWorkflowType)(value);
    if (!workflowType) {
      return false;
    }
    return workflowType === type;
  };
  WorkflowRuntimeType2.isTypeEqual = (leftType, rightType) => {
    if (leftType === WorkflowVariableType.Number && rightType === WorkflowVariableType.Integer || leftType === WorkflowVariableType.Integer && rightType === WorkflowVariableType.Number) {
      return true;
    }
    return leftType === rightType;
  };
})(WorkflowRuntimeType || (WorkflowRuntimeType = {}));

// src/domain/task/index.ts
var WorkflowRuntimeTask = class _WorkflowRuntimeTask {
  constructor(params) {
    this.id = uuid();
    this.context = params.context;
    this.processing = params.processing;
  }
  cancel() {
    this.context.statusCenter.workflow.cancel();
    const cancelNodeIDs = this.context.statusCenter.getStatusNodeIDs(WorkflowStatus.Processing);
    cancelNodeIDs.forEach((nodeID) => {
      this.context.statusCenter.nodeStatus(nodeID).cancel();
    });
  }
  static create(params) {
    return new _WorkflowRuntimeTask(params);
  }
};

// src/domain/variable/variable-store/index.ts
var import_lodash_es10 = require("lodash-es");

// src/domain/variable/variable-value-object/index.ts
var WorkflowRuntimeVariable;
((WorkflowRuntimeVariable2) => {
  WorkflowRuntimeVariable2.create = (params) => ({
    id: uuid(),
    ...params
  });
})(WorkflowRuntimeVariable || (WorkflowRuntimeVariable = {}));

// src/domain/variable/variable-store/index.ts
var WorkflowRuntimeVariableStore = class {
  constructor() {
    this.id = uuid();
  }
  init() {
    this.store = /* @__PURE__ */ new Map();
  }
  dispose() {
    this.store.clear();
  }
  setParent(parent) {
    this.parent = parent;
  }
  globalGet(nodeID) {
    const store = this.store.get(nodeID);
    if (!store && this.parent) {
      return this.parent.globalGet(nodeID);
    }
    return store;
  }
  setVariable(params) {
    const { nodeID, key, value, type, itemsType } = params;
    if (!this.store.has(nodeID)) {
      this.store.set(nodeID, /* @__PURE__ */ new Map());
    }
    const nodeStore = this.store.get(nodeID);
    const variable = WorkflowRuntimeVariable.create({
      nodeID,
      key,
      value,
      type,
      // TODO check type
      itemsType
      // TODO check is array
    });
    nodeStore.set(key, variable);
  }
  setValue(params) {
    const { nodeID, variableKey, variablePath, value } = params;
    if (!this.store.has(nodeID)) {
      this.store.set(nodeID, /* @__PURE__ */ new Map());
    }
    const nodeStore = this.store.get(nodeID);
    if (!nodeStore.has(variableKey)) {
      const variable2 = WorkflowRuntimeVariable.create({
        nodeID,
        key: variableKey,
        value: {},
        type: WorkflowVariableType.Object
      });
      nodeStore.set(variableKey, variable2);
    }
    const variable = nodeStore.get(variableKey);
    if (!variablePath) {
      variable.value = value;
      return;
    }
    (0, import_lodash_es10.set)(variable.value, variablePath, value);
  }
  getValue(params) {
    const { nodeID, variableKey, variablePath } = params;
    const variable = this.globalGet(nodeID)?.get(variableKey);
    if (!variable) {
      return null;
    }
    if (!variablePath || variablePath.length === 0) {
      return {
        value: variable.value,
        type: variable.type,
        itemsType: variable.itemsType
      };
    }
    const value = (0, import_lodash_es10.get)(variable.value, variablePath);
    const type = WorkflowRuntimeType.getWorkflowType(value);
    if (!type) {
      return null;
    }
    if (type === WorkflowVariableType.Array && Array.isArray(value)) {
      const itemsType = WorkflowRuntimeType.getWorkflowType(value[0]);
      if (!itemsType) {
        return null;
      }
      return {
        value,
        type,
        itemsType
      };
    }
    return {
      value,
      type
    };
  }
};

// src/domain/status/status-entity/index.ts
var WorkflowRuntimeStatus = class _WorkflowRuntimeStatus {
  constructor() {
    this.id = uuid();
    this._status = WorkflowStatus.Pending;
  }
  get status() {
    return this._status;
  }
  get terminated() {
    return [WorkflowStatus.Succeeded, WorkflowStatus.Failed, WorkflowStatus.Canceled].includes(
      this.status
    );
  }
  get startTime() {
    return this._startTime;
  }
  get endTime() {
    return this._endTime;
  }
  get timeCost() {
    if (!this.startTime) {
      return 0;
    }
    if (this.endTime) {
      return this.endTime - this.startTime;
    }
    return Date.now() - this.startTime;
  }
  process() {
    this._status = WorkflowStatus.Processing;
    this._startTime = Date.now();
    this._endTime = void 0;
  }
  success() {
    if (this.terminated) {
      return;
    }
    this._status = WorkflowStatus.Succeeded;
    this._endTime = Date.now();
  }
  fail() {
    if (this.terminated) {
      return;
    }
    this._status = WorkflowStatus.Failed;
    this._endTime = Date.now();
  }
  cancel() {
    if (this.terminated) {
      return;
    }
    this._status = WorkflowStatus.Canceled;
    this._endTime = Date.now();
  }
  export() {
    return {
      status: this.status,
      terminated: this.terminated,
      startTime: this.startTime,
      endTime: this.endTime,
      timeCost: this.timeCost
    };
  }
  static create() {
    const status = new _WorkflowRuntimeStatus();
    return status;
  }
};

// src/domain/status/status-center/index.ts
var WorkflowRuntimeStatusCenter = class {
  init() {
    this._workflowStatus = WorkflowRuntimeStatus.create();
    this._nodeStatus = /* @__PURE__ */ new Map();
  }
  dispose() {
  }
  get workflow() {
    return this._workflowStatus;
  }
  get workflowStatus() {
    return this._workflowStatus;
  }
  nodeStatus(nodeID) {
    if (!this._nodeStatus.has(nodeID)) {
      this._nodeStatus.set(nodeID, WorkflowRuntimeStatus.create());
    }
    const status = this._nodeStatus.get(nodeID);
    return status;
  }
  getStatusNodeIDs(status) {
    return Array.from(this._nodeStatus.entries()).filter(([, nodeStatus]) => nodeStatus.status === status).map(([nodeID]) => nodeID);
  }
  exportNodeStatus() {
    return Object.fromEntries(
      Array.from(this._nodeStatus.entries()).map(([nodeID, status]) => [nodeID, status.export()])
    );
  }
};

// src/domain/state/index.ts
var import_lodash_es11 = require("lodash-es");
var WorkflowRuntimeState = class {
  constructor(variableStore) {
    this.variableStore = variableStore;
    this.id = uuid();
  }
  init() {
    this.executedNodes = /* @__PURE__ */ new Set();
  }
  dispose() {
    this.executedNodes.clear();
  }
  getNodeInputs(node) {
    const inputsDeclare = node.declare.inputs;
    const inputsValues = node.declare.inputsValues;
    if (!inputsDeclare || !inputsValues) {
      return {};
    }
    return Object.entries(inputsValues).reduce((prev, [key, inputValue]) => {
      const typeInfo = inputsDeclare.properties?.[key];
      if (!typeInfo) {
        return prev;
      }
      const expectType = typeInfo.type;
      const result = this.parseValue(inputValue);
      if (!result) {
        return prev;
      }
      const { value, type } = result;
      if (!WorkflowRuntimeType.isTypeEqual(type, expectType)) {
        return prev;
      }
      prev[key] = value;
      return prev;
    }, {});
  }
  setNodeOutputs(params) {
    const { node, outputs } = params;
    const outputsDeclare = node.declare.outputs;
    if (!outputsDeclare) {
      return;
    }
    Object.entries(outputs).forEach(([key, value]) => {
      const typeInfo = outputsDeclare.properties?.[key];
      if (!typeInfo) {
        return;
      }
      const type = typeInfo.type;
      const itemsType = typeInfo.items?.type;
      this.variableStore.setVariable({
        nodeID: node.id,
        key,
        value,
        type,
        itemsType
      });
    });
  }
  parseRef(ref) {
    if (ref?.type !== "ref") {
      throw new Error(`invalid ref value: ${ref}`);
    }
    if (!ref.content || ref.content.length < 2) {
      return null;
    }
    const [nodeID, variableKey, ...variablePath] = ref.content;
    const result = this.variableStore.getValue({
      nodeID,
      variableKey,
      variablePath
    });
    if (!result) {
      return null;
    }
    return result;
  }
  parseValue(flowValue) {
    if (!flowValue?.type) {
      throw new Error(`invalid flow value type: ${flowValue.type}`);
    }
    if (flowValue.type === "constant") {
      const value = flowValue.content;
      const type = WorkflowRuntimeType.getWorkflowType(value);
      if ((0, import_lodash_es11.isNil)(value) || !type) {
        return null;
      }
      return {
        value,
        type
      };
    }
    if (flowValue.type === "ref") {
      return this.parseRef(flowValue);
    }
    throw new Error(`unknown flow value type: ${flowValue.type}`);
  }
  isExecutedNode(node) {
    return this.executedNodes.has(node.id);
  }
  addExecutedNode(node) {
    this.executedNodes.add(node.id);
  }
};

// src/domain/snapshot/snapshot-entity/index.ts
var WorkflowRuntimeSnapshot = class _WorkflowRuntimeSnapshot {
  constructor(data) {
    this.id = uuid();
    this.data = data;
  }
  addData(data) {
    Object.assign(this.data, data);
  }
  validate() {
    const required = ["nodeID", "inputs", "outputs", "data"];
    return required.every((key) => this.data[key] !== void 0);
  }
  export() {
    const snapshot = {
      id: this.id,
      ...this.data
    };
    return snapshot;
  }
  static create(params) {
    return new _WorkflowRuntimeSnapshot(params);
  }
};

// src/domain/snapshot/snapshot-center/index.ts
var WorkflowRuntimeSnapshotCenter = class {
  constructor() {
    this.id = uuid();
  }
  create(snapshotData) {
    const snapshot = WorkflowRuntimeSnapshot.create(snapshotData);
    this.snapshots.push(snapshot);
    return snapshot;
  }
  init() {
    this.snapshots = [];
  }
  dispose() {
  }
  exportAll() {
    return this.snapshots.slice().map((snapshot) => snapshot.export());
  }
  export() {
    const result = {};
    this.exportAll().forEach((snapshot) => {
      if (result[snapshot.nodeID]) {
        result[snapshot.nodeID].push(snapshot);
      } else {
        result[snapshot.nodeID] = [snapshot];
      }
    });
    return result;
  }
};

// src/domain/report/report-value-object/index.ts
var WorkflowRuntimeReport;
((WorkflowRuntimeReport2) => {
  WorkflowRuntimeReport2.create = (params) => ({
    id: uuid(),
    ...params
  });
})(WorkflowRuntimeReport || (WorkflowRuntimeReport = {}));

// src/domain/report/reporter/index.ts
var WorkflowRuntimeReporter = class {
  constructor(ioCenter, snapshotCenter, statusCenter) {
    this.ioCenter = ioCenter;
    this.snapshotCenter = snapshotCenter;
    this.statusCenter = statusCenter;
  }
  init() {
  }
  dispose() {
  }
  export() {
    const report = WorkflowRuntimeReport.create({
      inputs: this.ioCenter.inputs,
      outputs: this.ioCenter.outputs,
      workflowStatus: this.statusCenter.workflow.export(),
      reports: this.nodeReports()
    });
    return report;
  }
  nodeReports() {
    const reports = {};
    const statuses = this.statusCenter.exportNodeStatus();
    const snapshots = this.snapshotCenter.export();
    Object.keys(statuses).forEach((nodeID) => {
      const status = statuses[nodeID];
      const nodeSnapshots = snapshots[nodeID] || [];
      const nodeReport = {
        id: nodeID,
        ...status,
        snapshots: nodeSnapshots
      };
      reports[nodeID] = nodeReport;
    });
    return reports;
  }
};

// src/domain/io-center/index.ts
var WorkflowRuntimeIOCenter = class {
  init(inputs) {
    this.setInputs(inputs);
  }
  dispose() {
  }
  get inputs() {
    return this._inputs ?? {};
  }
  get outputs() {
    return this._outputs ?? {};
  }
  setInputs(inputs) {
    this._inputs = inputs;
  }
  setOutputs(outputs) {
    this._outputs = outputs;
  }
  export() {
    return {
      inputs: this._inputs,
      outputs: this._outputs
    };
  }
};

// src/domain/document/entity/edge/index.ts
var WorkflowRuntimeEdge = class {
  constructor(params) {
    const { id, from, to } = params;
    this.id = id;
    this.from = from;
    this.to = to;
  }
  get fromPort() {
    return this._fromPort;
  }
  set fromPort(port) {
    this._fromPort = port;
  }
  get toPort() {
    return this._toPort;
  }
  set toPort(port) {
    this._toPort = port;
  }
  static createID(schema) {
    const { sourceNodeID, sourcePortID, targetNodeID, targetPortID } = schema;
    const sourcePart = sourcePortID ? `${sourceNodeID}:${sourcePortID}` : sourceNodeID;
    const targetPart = targetPortID ? `${targetNodeID}:${targetPortID}` : targetNodeID;
    return `${sourcePart}-${targetPart}`;
  }
};

// src/domain/document/entity/node/index.ts
var WorkflowRuntimeNode = class {
  constructor(params) {
    const { id, type, name, position, variable, data } = params;
    this.id = id;
    this.type = type;
    this.name = name;
    this.position = position;
    this.declare = variable ?? {};
    this.data = data ?? {};
    this._parent = null;
    this._children = [];
    this._ports = [];
    this._inputEdges = [];
    this._outputEdges = [];
    this._prev = [];
    this._next = [];
  }
  get ports() {
    const inputs = this._ports.filter((port) => port.type === WorkflowPortType.Input);
    const outputs = this._ports.filter((port) => port.type === WorkflowPortType.Output);
    return {
      inputs,
      outputs
    };
  }
  get edges() {
    return {
      inputs: this._inputEdges,
      outputs: this._outputEdges
    };
  }
  get parent() {
    return this._parent;
  }
  set parent(parent) {
    this._parent = parent;
  }
  get children() {
    return this._children;
  }
  addChild(child) {
    this._children.push(child);
  }
  addPort(port) {
    this._ports.push(port);
  }
  addInputEdge(edge) {
    this._inputEdges.push(edge);
    this._prev.push(edge.from);
  }
  addOutputEdge(edge) {
    this._outputEdges.push(edge);
    this._next.push(edge.to);
  }
  get prev() {
    return this._prev;
  }
  get next() {
    return this._next;
  }
  get isBranch() {
    return this.ports.outputs.length > 1;
  }
};

// src/domain/document/entity/port/index.ts
var WorkflowRuntimePort = class {
  constructor(params) {
    const { id, node } = params;
    this.id = id;
    this.node = node;
    this.type = params.type;
    this._edges = [];
  }
  get edges() {
    return this._edges;
  }
  addEdge(edge) {
    this._edges.push(edge);
  }
};

// src/domain/document/document/flat-schema.ts
var flatLayer = (data, nodeSchema) => {
  const { blocks, edges } = nodeSchema;
  if (blocks) {
    data.flattenSchema.nodes.push(...blocks);
    const blockIDs = [];
    blocks.forEach((block) => {
      blockIDs.push(block.id);
      if (block.blocks) {
        flatLayer(data, block);
      }
    });
    data.nodeBlocks.set(nodeSchema.id, blockIDs);
    delete nodeSchema.blocks;
  }
  if (edges) {
    data.flattenSchema.edges.push(...edges);
    const edgeIDs = [];
    edges.forEach((edge) => {
      const edgeID = WorkflowRuntimeEdge.createID(edge);
      edgeIDs.push(edgeID);
    });
    data.nodeEdges.set(nodeSchema.id, edgeIDs);
    delete nodeSchema.edges;
  }
};
var flatSchema = (schema = { nodes: [], edges: [] }) => {
  const rootNodes = schema.nodes ?? [];
  const rootEdges = schema.edges ?? [];
  const data = {
    flattenSchema: {
      nodes: [],
      edges: []
    },
    nodeBlocks: /* @__PURE__ */ new Map(),
    nodeEdges: /* @__PURE__ */ new Map()
  };
  const root = {
    id: FlowGramNode.Root,
    type: FlowGramNode.Root,
    blocks: rootNodes,
    edges: rootEdges,
    meta: {
      position: {
        x: 0,
        y: 0
      }
    },
    data: {}
  };
  flatLayer(data, root);
  return data;
};

// src/domain/document/document/create-store.ts
var createNode = (store, params) => {
  const node = new WorkflowRuntimeNode(params);
  store.nodes.set(node.id, node);
  return node;
};
var createEdge = (store, params) => {
  const edge = new WorkflowRuntimeEdge(params);
  store.edges.set(edge.id, edge);
  return edge;
};
var getOrCreatePort = (store, params) => {
  const createdPort = store.ports.get(params.id);
  if (createdPort) {
    return createdPort;
  }
  const port = new WorkflowRuntimePort(params);
  store.ports.set(port.id, port);
  return port;
};
var createStore = (params) => {
  const { flattenSchema, nodeBlocks } = params;
  const { nodes, edges } = flattenSchema;
  const store = {
    nodes: /* @__PURE__ */ new Map(),
    edges: /* @__PURE__ */ new Map(),
    ports: /* @__PURE__ */ new Map()
  };
  createNode(store, {
    id: FlowGramNode.Root,
    type: FlowGramNode.Root,
    name: FlowGramNode.Root,
    position: { x: 0, y: 0 }
  });
  nodes.forEach((nodeSchema) => {
    const id = nodeSchema.id;
    const type = nodeSchema.type;
    const {
      title = `${type}-${id}-untitled`,
      inputsValues,
      inputs,
      outputs,
      ...data
    } = nodeSchema.data ?? {};
    createNode(store, {
      id,
      type,
      name: title,
      position: nodeSchema.meta.position,
      variable: { inputsValues, inputs, outputs },
      data
    });
  });
  nodeBlocks.forEach((blockIDs, parentID) => {
    const parent = store.nodes.get(parentID);
    const children = blockIDs.map((id) => store.nodes.get(id)).filter(Boolean);
    children.forEach((child) => {
      child.parent = parent;
      parent.addChild(child);
    });
  });
  edges.forEach((edgeSchema) => {
    const id = WorkflowRuntimeEdge.createID(edgeSchema);
    const {
      sourceNodeID,
      targetNodeID,
      sourcePortID = "defaultOutput",
      targetPortID = "defaultInput"
    } = edgeSchema;
    const from = store.nodes.get(sourceNodeID);
    const to = store.nodes.get(targetNodeID);
    if (!from || !to) {
      throw new Error(`invalid edge schema ID: ${id}, from: ${sourceNodeID}, to: ${targetNodeID}`);
    }
    const edge = createEdge(store, {
      id,
      from,
      to
    });
    const fromPort = getOrCreatePort(store, {
      node: from,
      id: sourcePortID,
      type: WorkflowPortType.Output
    });
    fromPort.addEdge(edge);
    edge.fromPort = fromPort;
    from.addPort(fromPort);
    from.addOutputEdge(edge);
    const toPort = getOrCreatePort(store, {
      node: to,
      id: targetPortID,
      type: WorkflowPortType.Input
    });
    toPort.addEdge(edge);
    edge.toPort = toPort;
    to.addPort(toPort);
    to.addInputEdge(edge);
  });
  return store;
};

// src/domain/document/document/index.ts
var WorkflowRuntimeDocument = class {
  constructor() {
    this.id = uuid();
  }
  get root() {
    const rootNode = this.getNode(FlowGramNode.Root);
    if (!rootNode) {
      throw new Error("Root node not found");
    }
    return rootNode;
  }
  get start() {
    const startNode = this.nodes.find((n) => n.type === FlowGramNode.Start);
    if (!startNode) {
      throw new Error("Start node not found");
    }
    return startNode;
  }
  get end() {
    const endNode = this.nodes.find((n) => n.type === FlowGramNode.End);
    if (!endNode) {
      throw new Error("End node not found");
    }
    return endNode;
  }
  getNode(id) {
    return this.store.nodes.get(id) ?? null;
  }
  getEdge(id) {
    return this.store.edges.get(id) ?? null;
  }
  get nodes() {
    return Array.from(this.store.nodes.values());
  }
  get edges() {
    return Array.from(this.store.edges.values());
  }
  init(schema) {
    const flattenSchema = flatSchema(schema);
    this.store = createStore(flattenSchema);
  }
  dispose() {
    this.store.edges.clear();
    this.store.nodes.clear();
    this.store.ports.clear();
  }
};

// src/domain/context/index.ts
var WorkflowRuntimeContext = class _WorkflowRuntimeContext {
  constructor(data) {
    this.subContexts = [];
    this.id = uuid();
    this.document = data.document;
    this.variableStore = data.variableStore;
    this.state = data.state;
    this.ioCenter = data.ioCenter;
    this.snapshotCenter = data.snapshotCenter;
    this.statusCenter = data.statusCenter;
    this.reporter = data.reporter;
  }
  init(params) {
    const { schema, inputs } = params;
    this.document.init(schema);
    this.variableStore.init();
    this.state.init();
    this.ioCenter.init(inputs);
    this.snapshotCenter.init();
    this.statusCenter.init();
    this.reporter.init();
  }
  dispose() {
    this.subContexts.forEach((subContext) => {
      subContext.dispose();
    });
    this.subContexts = [];
    this.document.dispose();
    this.variableStore.dispose();
    this.state.dispose();
    this.ioCenter.dispose();
    this.snapshotCenter.dispose();
    this.statusCenter.dispose();
    this.reporter.dispose();
  }
  sub() {
    const variableStore = new WorkflowRuntimeVariableStore();
    variableStore.setParent(this.variableStore);
    const state = new WorkflowRuntimeState(variableStore);
    const contextData = {
      document: this.document,
      ioCenter: this.ioCenter,
      snapshotCenter: this.snapshotCenter,
      statusCenter: this.statusCenter,
      reporter: this.reporter,
      variableStore,
      state
    };
    const subContext = new _WorkflowRuntimeContext(contextData);
    this.subContexts.push(subContext);
    subContext.variableStore.init();
    subContext.state.init();
    return subContext;
  }
  static create() {
    const document = new WorkflowRuntimeDocument();
    const variableStore = new WorkflowRuntimeVariableStore();
    const state = new WorkflowRuntimeState(variableStore);
    const ioCenter = new WorkflowRuntimeIOCenter();
    const snapshotCenter = new WorkflowRuntimeSnapshotCenter();
    const statusCenter = new WorkflowRuntimeStatusCenter();
    const reporter = new WorkflowRuntimeReporter(ioCenter, snapshotCenter, statusCenter);
    return new _WorkflowRuntimeContext({
      document,
      variableStore,
      state,
      ioCenter,
      snapshotCenter,
      statusCenter,
      reporter
    });
  }
};

// src/domain/engine/index.ts
var WorkflowRuntimeEngine = class {
  constructor(service) {
    this.executor = service.Executor;
  }
  invoke(params) {
    const context = WorkflowRuntimeContext.create();
    context.init(params);
    const processing = this.process(context);
    processing.then(() => {
      context.dispose();
    });
    return WorkflowRuntimeTask.create({
      processing,
      context
    });
  }
  async executeNode(params) {
    const { node, context } = params;
    if (!this.canExecuteNode({ node, context })) {
      return;
    }
    context.statusCenter.nodeStatus(node.id).process();
    try {
      const inputs = context.state.getNodeInputs(node);
      const snapshot = context.snapshotCenter.create({
        nodeID: node.id,
        data: node.data,
        inputs
      });
      const result = await this.executor.execute({
        node,
        inputs,
        runtime: context,
        container: WorkflowRuntimeContainer.instance
      });
      if (context.statusCenter.workflow.terminated) {
        return;
      }
      const { outputs, branch } = result;
      snapshot.addData({ outputs, branch });
      context.state.setNodeOutputs({ node, outputs });
      context.state.addExecutedNode(node);
      context.statusCenter.nodeStatus(node.id).success();
      const nextNodes = this.getNextNodes({ node, branch, context });
      await this.executeNext({ node, nextNodes, context });
    } catch (e) {
      context.statusCenter.nodeStatus(node.id).fail();
      console.error(e);
      return;
    }
  }
  async process(context) {
    const startNode = context.document.start;
    context.statusCenter.workflow.process();
    try {
      await this.executeNode({ node: startNode, context });
      const outputs = context.ioCenter.outputs;
      context.statusCenter.workflow.success();
      return outputs;
    } catch (e) {
      context.statusCenter.workflow.fail();
      throw e;
    }
  }
  canExecuteNode(params) {
    const { node, context } = params;
    const prevNodes = node.prev;
    if (prevNodes.length === 0) {
      return true;
    }
    return prevNodes.every((prevNode) => context.state.isExecutedNode(prevNode));
  }
  getNextNodes(params) {
    const { node, branch, context } = params;
    const allNextNodes = node.next;
    if (!branch) {
      return allNextNodes;
    }
    const targetPort = node.ports.outputs.find((port) => port.id === branch);
    if (!targetPort) {
      throw new Error(`branch ${branch} not found`);
    }
    const nextNodeIDs = new Set(targetPort.edges.map((edge) => edge.to.id));
    const nextNodes = allNextNodes.filter((nextNode) => nextNodeIDs.has(nextNode.id));
    const skipNodes = allNextNodes.filter((nextNode) => !nextNodeIDs.has(nextNode.id));
    skipNodes.forEach((skipNode) => {
      context.state.addExecutedNode(skipNode);
    });
    return nextNodes;
  }
  async executeNext(params) {
    const { context, node, nextNodes } = params;
    if (node.type === FlowGramNode.End) {
      return;
    }
    if (nextNodes.length === 0) {
      return;
    }
    await Promise.all(
      nextNodes.map(
        (nextNode) => this.executeNode({
          node: nextNode,
          context
        })
      )
    );
  }
};

// src/domain/container/index.ts
var WorkflowRuntimeContainer = class _WorkflowRuntimeContainer {
  constructor(services) {
    this.services = services;
  }
  get(key) {
    return this.services[key];
  }
  static get instance() {
    if (this._instance) {
      return this._instance;
    }
    const services = this.create();
    this._instance = new _WorkflowRuntimeContainer(services);
    return this._instance;
  }
  static create() {
    const Validation = new WorkflowRuntimeValidation();
    const Executor = new WorkflowRuntimeExecutor(WorkflowRuntimeNodeExecutors);
    const Engine = new WorkflowRuntimeEngine({
      Executor
    });
    return {
      [IValidation]: Validation,
      [IExecutor]: Executor,
      [IEngine]: Engine
    };
  }
};

// src/application/workflow.ts
var WorkflowApplication = class _WorkflowApplication {
  constructor() {
    this.container = WorkflowRuntimeContainer.instance;
    this.tasks = /* @__PURE__ */ new Map();
  }
  run(params) {
    const engine = this.container.get(IEngine);
    const task = engine.invoke(params);
    this.tasks.set(task.id, task);
    console.log("> POST TaskRun - taskID: ", task.id);
    console.log(params.inputs);
    task.processing.then((output) => {
      console.log("> LOG Task finished: ", task.id);
      console.log(output);
    });
    return task.id;
  }
  cancel(taskID) {
    console.log("> PUT TaskCancel - taskID: ", taskID);
    const task = this.tasks.get(taskID);
    if (!task) {
      return false;
    }
    task.cancel();
    return true;
  }
  report(taskID) {
    const task = this.tasks.get(taskID);
    console.log("> GET TaskReport - taskID: ", taskID);
    if (!task) {
      return;
    }
    return task.context.reporter.export();
  }
  result(taskID) {
    console.log("> GET TaskResult - taskID: ", taskID);
    const task = this.tasks.get(taskID);
    if (!task) {
      return;
    }
    if (!task.context.statusCenter.workflow.terminated) {
      return;
    }
    return task.context.ioCenter.outputs;
  }
  static get instance() {
    if (this._instance) {
      return this._instance;
    }
    this._instance = new _WorkflowApplication();
    return this._instance;
  }
};

// src/api/task-run.ts
var TaskRunAPI = async (input) => {
  const app = WorkflowApplication.instance;
  const { schema: stringSchema, inputs } = input;
  const schema = JSON.parse(stringSchema);
  const taskID = app.run({
    schema,
    inputs
  });
  const output = {
    taskID
  };
  return output;
};

// src/api/task-result.ts
var TaskResultAPI = async (input) => {
  const app = WorkflowApplication.instance;
  const { taskID } = input;
  const output = app.result(taskID);
  return output;
};

// src/api/task-report.ts
var TaskReportAPI = async (input) => {
  const app = WorkflowApplication.instance;
  const { taskID } = input;
  const output = app.report(taskID);
  try {
    TaskReportDefine.schema.output.parse(output);
  } catch (e) {
    console.log("> TaskReportAPI - output: ", JSON.stringify(output));
    console.error(e);
  }
  return output;
};

// src/api/task-cancel.ts
var TaskCancelAPI = async (input) => {
  const app = WorkflowApplication.instance;
  const { taskID } = input;
  const success = app.cancel(taskID);
  const output = {
    success
  };
  return output;
};

// src/api/index.ts
var WorkflowRuntimeAPIs = {
  [FlowGramAPIName.TaskRun]: TaskRunAPI,
  [FlowGramAPIName.TaskReport]: TaskReportAPI,
  [FlowGramAPIName.TaskResult]: TaskResultAPI,
  [FlowGramAPIName.TaskCancel]: TaskCancelAPI,
  [FlowGramAPIName.ServerInfo]: () => {
  },
  // TODO
  [FlowGramAPIName.Validation]: () => {
  }
  // TODO
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  TaskCancelAPI,
  TaskReportAPI,
  TaskResultAPI,
  TaskRunAPI,
  WorkflowRuntimeAPIs
});
//# sourceMappingURL=index.js.map