{"version":3,"sources":["../../../interface/src/api/validation/index.ts","../../../interface/src/api/constant.ts","../../../interface/src/api/task-run/index.ts","../../../interface/src/api/schema.ts","../../../interface/src/api/task-result/index.ts","../../../interface/src/api/task-report/index.ts","../../../interface/src/api/task-cancel/index.ts","../../../interface/src/api/server-info/index.ts","../../../interface/src/api/define.ts","../../../interface/src/schema/constant.ts","../../../interface/src/node/constant.ts","../../../interface/src/runtime/engine/index.ts","../../../interface/src/runtime/executor/executor.ts","../../../interface/src/runtime/status/index.ts","../../../interface/src/runtime/validation/index.ts","../../src/nodes/start/index.ts","../../src/nodes/loop/index.ts","../../src/nodes/llm/index.ts","../../src/nodes/end/index.ts","../../src/nodes/condition/index.ts","../../src/nodes/condition/rules.ts","../../src/nodes/condition/handlers/string.ts","../../src/nodes/condition/handlers/object.ts","../../src/nodes/condition/handlers/number.ts","../../src/nodes/condition/handlers/null.ts","../../src/nodes/condition/handlers/boolean.ts","../../src/nodes/condition/handlers/array.ts","../../src/nodes/condition/handlers/index.ts","../../src/nodes/index.ts","../../src/domain/validation/index.ts","../../src/domain/executor/index.ts","../../src/infrastructure/utils/uuid.ts","../../src/infrastructure/utils/runtime-type.ts","../../src/domain/task/index.ts","../../src/domain/variable/variable-store/index.ts","../../src/domain/variable/variable-value-object/index.ts","../../src/domain/status/status-entity/index.ts","../../src/domain/status/status-center/index.ts","../../src/domain/state/index.ts","../../src/domain/snapshot/snapshot-entity/index.ts","../../src/domain/snapshot/snapshot-center/index.ts","../../src/domain/report/report-value-object/index.ts","../../src/domain/report/reporter/index.ts","../../src/domain/io-center/index.ts","../../src/domain/document/entity/edge/index.ts","../../src/domain/document/entity/node/index.ts","../../src/domain/document/entity/port/index.ts","../../src/domain/document/document/flat-schema.ts","../../src/domain/document/document/create-store.ts","../../src/domain/document/document/index.ts","../../src/domain/context/index.ts","../../src/domain/engine/index.ts","../../src/domain/container/index.ts","../../src/application/workflow.ts","../../src/api/task-run.ts","../../src/api/task-result.ts","../../src/api/task-report.ts","../../src/api/task-cancel.ts","../../src/api/index.ts"],"sourcesContent":["import z from 'zod';\n\nimport { ValidationResult } from '@runtime/index';\nimport { FlowGramAPIDefine } from '@api/type';\nimport { FlowGramAPIMethod, FlowGramAPIModule, FlowGramAPIName } from '@api/constant';\n\nexport interface ValidationReq {\n  schema: string;\n}\n\nexport interface ValidationRes extends ValidationResult {}\n\nexport const ValidationDefine: FlowGramAPIDefine = {\n  name: FlowGramAPIName.Validation,\n  method: FlowGramAPIMethod.POST,\n  path: '/validation',\n  module: FlowGramAPIModule.Validation,\n  schema: {\n    input: z.object({\n      schema: z.string(),\n    }),\n    output: z.object({\n      valid: z.boolean(),\n      nodeErrors: z.array(\n        z.object({\n          message: z.string(),\n          nodeID: z.string(),\n        })\n      ),\n      edgeErrors: z.array(\n        z.object({\n          message: z.string(),\n          edge: z.object({\n            sourceNodeID: z.string(),\n            targetNodeID: z.string(),\n            sourcePortID: z.string().optional(),\n            targetPortID: z.string().optional(),\n          }),\n        })\n      ),\n    }),\n  },\n};\n","export enum FlowGramAPIMethod {\n  GET = 'GET',\n  POST = 'POST',\n  PUT = 'PUT',\n  DELETE = 'DELETE',\n  PATCH = 'PATCH',\n}\n\nexport enum FlowGramAPIName {\n  ServerInfo = 'ServerInfo',\n  TaskRun = 'TaskRun',\n  TaskReport = 'TaskReport',\n  TaskResult = 'TaskResult',\n  TaskCancel = 'TaskCancel',\n  Validation = 'Validation',\n}\n\nexport enum FlowGramAPIModule {\n  Info = 'Info',\n  Task = 'Task',\n  Validation = 'Validation',\n}\n","import z from 'zod';\n\nimport { WorkflowInputs } from '@runtime/index';\nimport { FlowGramAPIDefine } from '@api/type';\nimport { WorkflowZodSchema } from '@api/schema';\nimport { FlowGramAPIMethod, FlowGramAPIModule, FlowGramAPIName } from '@api/constant';\n\nexport interface TaskRunInput {\n  inputs: WorkflowInputs;\n  schema: string;\n}\n\nexport interface TaskRunOutput {\n  taskID: string;\n}\n\nexport const TaskRunDefine: FlowGramAPIDefine = {\n  name: FlowGramAPIName.TaskRun,\n  method: FlowGramAPIMethod.POST,\n  path: '/task/run',\n  module: FlowGramAPIModule.Task,\n  schema: {\n    input: z.object({\n      schema: z.string(),\n      inputs: WorkflowZodSchema.Inputs,\n    }),\n    output: z.object({\n      taskID: z.string(),\n    }),\n  },\n};\n","import z from 'zod';\n\nconst WorkflowIOZodSchema = z.record(z.string(), z.any());\nconst WorkflowSnapshotZodSchema = z.object({\n  id: z.string(),\n  nodeID: z.string(),\n  inputs: WorkflowIOZodSchema,\n  outputs: WorkflowIOZodSchema.optional(),\n  data: WorkflowIOZodSchema,\n  branch: z.string().optional(),\n});\nconst WorkflowStatusZodShape = {\n  status: z.string(),\n  terminated: z.boolean(),\n  startTime: z.number(),\n  endTime: z.number().optional(),\n  timeCost: z.number(),\n};\nconst WorkflowStatusZodSchema = z.object(WorkflowStatusZodShape);\n\nexport const WorkflowZodSchema = {\n  Inputs: WorkflowIOZodSchema,\n  Outputs: WorkflowIOZodSchema,\n  Status: WorkflowStatusZodSchema,\n  Snapshot: WorkflowSnapshotZodSchema,\n  NodeReport: z.object({\n    id: z.string(),\n    ...WorkflowStatusZodShape,\n    snapshots: z.array(WorkflowSnapshotZodSchema),\n  }),\n};\n","import z from 'zod';\n\nimport { WorkflowOutputs } from '@runtime/index';\nimport { FlowGramAPIDefine } from '@api/type';\nimport { WorkflowZodSchema } from '@api/schema';\nimport { FlowGramAPIName, FlowGramAPIMethod, FlowGramAPIModule } from '@api/constant';\n\nexport interface TaskResultInput {\n  taskID: string;\n}\n\nexport type TaskResultOutput = WorkflowOutputs | undefined;\n\nexport const TaskResultDefine: FlowGramAPIDefine = {\n  name: FlowGramAPIName.TaskResult,\n  method: FlowGramAPIMethod.GET,\n  path: '/task/result',\n  module: FlowGramAPIModule.Task,\n  schema: {\n    input: z.object({\n      taskID: z.string(),\n    }),\n    output: WorkflowZodSchema.Outputs,\n  },\n};\n","import z from 'zod';\n\nimport { IReport } from '@runtime/index';\nimport { FlowGramAPIDefine } from '@api/type';\nimport { WorkflowZodSchema } from '@api/schema';\nimport { FlowGramAPIName, FlowGramAPIMethod, FlowGramAPIModule } from '@api/constant';\n\nexport interface TaskReportInput {\n  taskID: string;\n}\n\nexport type TaskReportOutput = IReport | undefined;\n\nexport const TaskReportDefine: FlowGramAPIDefine = {\n  name: FlowGramAPIName.TaskReport,\n  method: FlowGramAPIMethod.GET,\n  path: '/task/report',\n  module: FlowGramAPIModule.Task,\n  schema: {\n    input: z.object({\n      taskID: z.string(),\n    }),\n    output: z.object({\n      id: z.string(),\n      inputs: WorkflowZodSchema.Inputs,\n      outputs: WorkflowZodSchema.Outputs,\n      workflowStatus: WorkflowZodSchema.Status,\n      reports: z.record(z.string(), WorkflowZodSchema.NodeReport),\n    }),\n  },\n};\n","import z from 'zod';\n\nimport { FlowGramAPIDefine } from '@api/type';\nimport { FlowGramAPIName, FlowGramAPIMethod, FlowGramAPIModule } from '@api/constant';\n\nexport interface TaskCancelInput {\n  taskID: string;\n}\n\nexport type TaskCancelOutput = {\n  success: boolean;\n};\n\nexport const TaskCancelDefine: FlowGramAPIDefine = {\n  name: FlowGramAPIName.TaskCancel,\n  method: FlowGramAPIMethod.PUT,\n  path: '/task/cancel',\n  module: FlowGramAPIModule.Task,\n  schema: {\n    input: z.object({\n      taskID: z.string(),\n    }),\n    output: z.object({\n      success: z.boolean(),\n    }),\n  },\n};\n","import z from 'zod';\n\nimport { type FlowGramAPIDefine } from '@api/type';\nimport { FlowGramAPIMethod, FlowGramAPIModule, FlowGramAPIName } from '@api/constant';\n\nexport interface ServerInfoInput {}\n\nexport interface ServerInfoOutput {\n  name: string;\n  title: string;\n  description: string;\n  runtime: string;\n  version: string;\n  time: string;\n}\n\nexport const ServerInfoDefine: FlowGramAPIDefine = {\n  name: FlowGramAPIName.ServerInfo,\n  method: FlowGramAPIMethod.GET,\n  path: '/info',\n  module: FlowGramAPIModule.Info,\n  schema: {\n    input: z.undefined(),\n    output: z.object({\n      name: z.string(),\n      runtime: z.string(),\n      version: z.string(),\n      time: z.string(),\n    }),\n  },\n};\n","import { ValidationDefine } from './validation';\nimport { FlowGramAPIDefines } from './type';\nimport { TaskRunDefine } from './task-run';\nimport { TaskResultDefine } from './task-result';\nimport { TaskReportDefine } from './task-report';\nimport { TaskCancelDefine } from './task-cancel';\nimport { ServerInfoDefine } from './server-info';\nimport { FlowGramAPIName } from './constant';\n\nexport const FlowGramAPIs: FlowGramAPIDefines = {\n  [FlowGramAPIName.ServerInfo]: ServerInfoDefine,\n  [FlowGramAPIName.TaskRun]: TaskRunDefine,\n  [FlowGramAPIName.TaskReport]: TaskReportDefine,\n  [FlowGramAPIName.TaskResult]: TaskResultDefine,\n  [FlowGramAPIName.TaskCancel]: TaskCancelDefine,\n  [FlowGramAPIName.Validation]: ValidationDefine,\n};\n\nexport const FlowGramAPINames = Object.keys(FlowGramAPIs) as FlowGramAPIName[];\n","export enum WorkflowPortType {\n  Input = 'input',\n  Output = 'output',\n}\n\nexport enum WorkflowVariableType {\n  String = 'string',\n  Integer = 'integer',\n  Number = 'number',\n  Boolean = 'boolean',\n  Object = 'object',\n  Array = 'array',\n  Null = 'null',\n}\n","export enum FlowGramNode {\n  Root = 'root',\n  Start = 'start',\n  End = 'end',\n  LLM = 'llm',\n  code = 'code',\n  Condition = 'condition',\n  Loop = 'loop',\n  Comment = 'comment',\n  Group = 'group',\n}\n","import { ITask } from '../task';\nimport { IExecutor } from '../executor';\nimport { INode } from '../document';\nimport { IContext } from '../context';\nimport { InvokeParams } from '../base';\n\nexport interface EngineServices {\n  Executor: IExecutor;\n}\n\nexport interface IEngine {\n  invoke(params: InvokeParams): ITask;\n  executeNode(params: { context: IContext; node: INode }): Promise<void>;\n}\n\nexport const IEngine = Symbol.for('Engine');\n","import { ExecutionContext, ExecutionResult, INodeExecutor } from './node-executor';\n\nexport interface IExecutor {\n  execute: (context: ExecutionContext) => Promise<ExecutionResult>;\n  register: (executor: INodeExecutor) => void;\n}\n\nexport const IExecutor = Symbol.for('Executor');\n","export enum WorkflowStatus {\n  Pending = 'pending',\n  Processing = 'processing',\n  Succeeded = 'succeeded',\n  Failed = 'failed',\n  Canceled = 'canceled',\n}\n\nexport interface StatusData {\n  status: WorkflowStatus;\n  terminated: boolean;\n  startTime: number;\n  endTime?: number;\n  timeCost: number;\n}\n\nexport interface IStatus extends StatusData {\n  id: string;\n  process(): void;\n  success(): void;\n  fail(): void;\n  cancel(): void;\n  export(): StatusData;\n}\n\nexport interface IStatusCenter {\n  workflow: IStatus;\n  nodeStatus(nodeID: string): IStatus;\n  init(): void;\n  dispose(): void;\n  getStatusNodeIDs(status: WorkflowStatus): string[];\n  exportNodeStatus(): Record<string, StatusData>;\n}\n","import { WorkflowSchema } from '@schema/index';\n\nexport interface ValidationResult {\n  valid: boolean;\n  errors?: string[];\n}\n\nexport interface IValidation {\n  validate(schema: WorkflowSchema): ValidationResult;\n}\n\nexport const IValidation = Symbol.for('Validation');\n","import {\n  ExecutionContext,\n  ExecutionResult,\n  FlowGramNode,\n  INodeExecutor,\n} from '@flowgram.ai/runtime-interface';\n\nexport class StartExecutor implements INodeExecutor {\n  public type = FlowGramNode.Start;\n\n  public async execute(context: ExecutionContext): Promise<ExecutionResult> {\n    return {\n      outputs: context.runtime.ioCenter.inputs,\n    };\n  }\n}\n","import { isNil } from 'lodash-es';\nimport {\n  ExecutionContext,\n  ExecutionResult,\n  FlowGramNode,\n  IEngine,\n  INodeExecutor,\n  IVariableParseResult,\n  WorkflowVariableType,\n} from '@flowgram.ai/runtime-interface';\n\ntype LoopArray = Array<any>;\n\nexport interface LoopExecutorInputs {\n  batchFor: LoopArray;\n}\n\nexport class LoopExecutor implements INodeExecutor {\n  public type = FlowGramNode.Loop;\n\n  public async execute(context: ExecutionContext): Promise<ExecutionResult> {\n    const loopNodeID = context.node.id;\n    const loopArrayResult = context.runtime.state.parseRef<LoopArray>(context.node.data.batchFor)!;\n    this.checkLoopArray(loopArrayResult);\n\n    const loopArray = loopArrayResult.value;\n    const itemsType = loopArrayResult.itemsType!;\n    const engine = context.container.get<IEngine>(IEngine);\n    const subNodes = context.node.children;\n    const startSubNodes = subNodes.filter((node) => node.prev.length === 0);\n\n    if (loopArray.length === 0 || startSubNodes.length === 0) {\n      return {\n        outputs: {},\n      };\n    }\n\n    // not use Array method to make error stack more concise, and better performance\n    for (let i = 0; i < loopArray.length; i++) {\n      const loopItem = loopArray[i];\n      const subContext = context.runtime.sub();\n      subContext.variableStore.setVariable({\n        nodeID: `${loopNodeID}_locals`,\n        key: 'item',\n        type: itemsType,\n        value: loopItem,\n      });\n      await Promise.all(\n        startSubNodes.map((node) =>\n          engine.executeNode({\n            context: subContext,\n            node,\n          })\n        )\n      );\n    }\n\n    return {\n      outputs: {},\n    };\n  }\n\n  private checkLoopArray(loopArrayResult: IVariableParseResult<LoopArray> | null): void {\n    const loopArray = loopArrayResult?.value;\n    if (!loopArray || isNil(loopArray) || !Array.isArray(loopArray)) {\n      throw new Error('batchFor is required');\n    }\n    const loopArrayType = loopArrayResult.type;\n    if (loopArrayType !== WorkflowVariableType.Array) {\n      throw new Error('batchFor must be an array');\n    }\n    const loopArrayItemType = loopArrayResult.itemsType;\n    if (isNil(loopArrayItemType)) {\n      throw new Error('batchFor items must be array items');\n    }\n  }\n}\n","import { isNil } from 'lodash-es';\nimport { ChatOpenAI } from '@langchain/openai';\nimport { SystemMessage, HumanMessage, BaseMessageLike } from '@langchain/core/messages';\nimport {\n  ExecutionContext,\n  ExecutionResult,\n  FlowGramNode,\n  INodeExecutor,\n} from '@flowgram.ai/runtime-interface';\n\nexport interface LLMExecutorInputs {\n  modelName: string;\n  apiKey: string;\n  apiHost: string;\n  temperature: number;\n  systemPrompt?: string;\n  prompt: string;\n}\n\nexport class LLMExecutor implements INodeExecutor {\n  public type = FlowGramNode.LLM;\n\n  public async execute(context: ExecutionContext): Promise<ExecutionResult> {\n    const inputs = context.inputs as LLMExecutorInputs;\n    this.checkInputs(inputs);\n\n    const { modelName, temperature, apiKey, apiHost, systemPrompt, prompt } = inputs;\n\n    const model = new ChatOpenAI({\n      modelName,\n      temperature,\n      apiKey,\n      configuration: {\n        baseURL: apiHost,\n      },\n    });\n\n    const messages: BaseMessageLike[] = [];\n\n    if (systemPrompt) {\n      messages.push(new SystemMessage(systemPrompt));\n    }\n    messages.push(new HumanMessage(prompt));\n\n    const apiMessage = await model.invoke(messages);\n\n    const result = apiMessage.content;\n    return {\n      outputs: {\n        result,\n      },\n    };\n  }\n\n  protected checkInputs(inputs: LLMExecutorInputs) {\n    const { modelName, temperature, apiKey, apiHost, prompt } = inputs;\n    const missingInputs = [];\n\n    if (isNil(modelName)) missingInputs.push('modelName');\n    if (isNil(temperature)) missingInputs.push('temperature');\n    if (isNil(apiKey)) missingInputs.push('apiKey');\n    if (isNil(apiHost)) missingInputs.push('apiHost');\n    if (isNil(prompt)) missingInputs.push('prompt');\n\n    if (missingInputs.length > 0) {\n      throw new Error(`LLM node missing required inputs: ${missingInputs.join(', ')}`);\n    }\n  }\n}\n","import {\n  ExecutionContext,\n  ExecutionResult,\n  FlowGramNode,\n  INodeExecutor,\n} from '@flowgram.ai/runtime-interface';\n\nexport class EndExecutor implements INodeExecutor {\n  public type = FlowGramNode.End;\n\n  public async execute(context: ExecutionContext): Promise<ExecutionResult> {\n    context.runtime.ioCenter.setOutputs(context.inputs);\n    return {\n      outputs: context.inputs,\n    };\n  }\n}\n","import { isNil } from 'lodash-es';\nimport {\n  ExecutionContext,\n  ExecutionResult,\n  FlowGramNode,\n  INodeExecutor,\n  WorkflowVariableType,\n} from '@flowgram.ai/runtime-interface';\n\nimport { ConditionItem, ConditionValue, Conditions } from './type';\nimport { conditionRules } from './rules';\nimport { conditionHandlers } from './handlers';\n\nexport class ConditionExecutor implements INodeExecutor {\n  public type = FlowGramNode.Condition;\n\n  public async execute(context: ExecutionContext): Promise<ExecutionResult> {\n    const conditions: Conditions = context.node.data?.conditions;\n    if (!conditions) {\n      return {\n        outputs: {},\n      };\n    }\n    const parsedConditions = conditions\n      .map((item) => this.parseCondition(item, context))\n      .filter((item) => this.checkCondition(item));\n    const activatedCondition = parsedConditions.find((item) => this.handleCondition(item));\n    if (!activatedCondition) {\n      return {\n        outputs: {},\n      };\n    }\n    return {\n      outputs: {},\n      branch: activatedCondition.key,\n    };\n  }\n\n  private parseCondition(item: ConditionItem, context: ExecutionContext): ConditionValue {\n    const { key, value } = item;\n    const { left, operator, right } = value;\n    const parsedLeft = context.runtime.state.parseRef(left);\n    const leftValue = parsedLeft?.value ?? null;\n    const leftType = parsedLeft?.type ?? WorkflowVariableType.Null;\n    const parsedRight = Boolean(right) ? context.runtime.state.parseValue(right) : null;\n    const rightValue = parsedRight?.value ?? null;\n    const rightType = parsedRight?.type ?? WorkflowVariableType.Null;\n    return {\n      key,\n      leftValue,\n      leftType,\n      rightValue,\n      rightType,\n      operator,\n    };\n  }\n\n  private checkCondition(condition: ConditionValue): boolean {\n    const rule = conditionRules[condition.leftType];\n    if (isNil(rule)) {\n      throw new Error(`condition left type ${condition.leftType} is not supported`);\n    }\n    const ruleType = rule[condition.operator];\n    if (isNil(ruleType)) {\n      throw new Error(`condition operator ${condition.operator} is not supported`);\n    }\n    if (ruleType !== condition.rightType) {\n      // throw new Error(`condition right type expected ${ruleType}, got ${condition.rightType}`);\n      return false;\n    }\n    return true;\n  }\n\n  private handleCondition(condition: ConditionValue): boolean {\n    const handler = conditionHandlers[condition.leftType];\n    if (!handler) {\n      throw new Error(`condition left type ${condition.leftType} is not supported`);\n    }\n    const isActive = handler(condition);\n    return isActive;\n  }\n}\n","import { WorkflowVariableType } from '@flowgram.ai/runtime-interface';\n\nimport { ConditionOperation, ConditionRules } from './type';\n\nexport const conditionRules: ConditionRules = {\n  [WorkflowVariableType.String]: {\n    [ConditionOperation.EQ]: WorkflowVariableType.String,\n    [ConditionOperation.NEQ]: WorkflowVariableType.String,\n    [ConditionOperation.CONTAINS]: WorkflowVariableType.String,\n    [ConditionOperation.NOT_CONTAINS]: WorkflowVariableType.String,\n    [ConditionOperation.IN]: WorkflowVariableType.Array,\n    [ConditionOperation.NIN]: WorkflowVariableType.Array,\n    [ConditionOperation.IS_EMPTY]: WorkflowVariableType.String,\n    [ConditionOperation.IS_NOT_EMPTY]: WorkflowVariableType.String,\n  },\n  [WorkflowVariableType.Number]: {\n    [ConditionOperation.EQ]: WorkflowVariableType.Number,\n    [ConditionOperation.NEQ]: WorkflowVariableType.Number,\n    [ConditionOperation.GT]: WorkflowVariableType.Number,\n    [ConditionOperation.GTE]: WorkflowVariableType.Number,\n    [ConditionOperation.LT]: WorkflowVariableType.Number,\n    [ConditionOperation.LTE]: WorkflowVariableType.Number,\n    [ConditionOperation.IN]: WorkflowVariableType.Array,\n    [ConditionOperation.NIN]: WorkflowVariableType.Array,\n    [ConditionOperation.IS_EMPTY]: WorkflowVariableType.Null,\n    [ConditionOperation.IS_NOT_EMPTY]: WorkflowVariableType.Null,\n  },\n  [WorkflowVariableType.Integer]: {\n    [ConditionOperation.EQ]: WorkflowVariableType.Integer,\n    [ConditionOperation.NEQ]: WorkflowVariableType.Integer,\n    [ConditionOperation.GT]: WorkflowVariableType.Integer,\n    [ConditionOperation.GTE]: WorkflowVariableType.Integer,\n    [ConditionOperation.LT]: WorkflowVariableType.Integer,\n    [ConditionOperation.LTE]: WorkflowVariableType.Integer,\n    [ConditionOperation.IN]: WorkflowVariableType.Array,\n    [ConditionOperation.NIN]: WorkflowVariableType.Array,\n    [ConditionOperation.IS_EMPTY]: WorkflowVariableType.Null,\n    [ConditionOperation.IS_NOT_EMPTY]: WorkflowVariableType.Null,\n  },\n  [WorkflowVariableType.Boolean]: {\n    [ConditionOperation.EQ]: WorkflowVariableType.Boolean,\n    [ConditionOperation.NEQ]: WorkflowVariableType.Boolean,\n    [ConditionOperation.IS_TRUE]: WorkflowVariableType.Null,\n    [ConditionOperation.IS_FALSE]: WorkflowVariableType.Null,\n    [ConditionOperation.IN]: WorkflowVariableType.Array,\n    [ConditionOperation.NIN]: WorkflowVariableType.Array,\n    [ConditionOperation.IS_EMPTY]: WorkflowVariableType.Null,\n    [ConditionOperation.IS_NOT_EMPTY]: WorkflowVariableType.Null,\n  },\n  [WorkflowVariableType.Object]: {\n    [ConditionOperation.IS_EMPTY]: WorkflowVariableType.Null,\n    [ConditionOperation.IS_NOT_EMPTY]: WorkflowVariableType.Null,\n  },\n  [WorkflowVariableType.Array]: {\n    [ConditionOperation.IS_EMPTY]: WorkflowVariableType.Null,\n    [ConditionOperation.IS_NOT_EMPTY]: WorkflowVariableType.Null,\n  },\n  [WorkflowVariableType.Null]: {\n    [ConditionOperation.EQ]: WorkflowVariableType.Null,\n    [ConditionOperation.IS_EMPTY]: WorkflowVariableType.Null,\n    [ConditionOperation.IS_NOT_EMPTY]: WorkflowVariableType.Null,\n  },\n};\n","import { isNil } from 'lodash-es';\n\nimport { ConditionHandler, ConditionOperation } from '../type';\n\nexport const conditionStringHandler: ConditionHandler = (condition) => {\n  const { operator } = condition;\n  const leftValue = condition.leftValue as string;\n  // Switch case share scope, so we need to use if else here\n  if (operator === ConditionOperation.EQ) {\n    const rightValue = condition.rightValue as string;\n    return leftValue === rightValue;\n  }\n  if (operator === ConditionOperation.NEQ) {\n    const rightValue = condition.rightValue as string;\n    return leftValue !== rightValue;\n  }\n  if (operator === ConditionOperation.CONTAINS) {\n    const rightValue = condition.rightValue as string;\n    return leftValue.includes(rightValue);\n  }\n  if (operator === ConditionOperation.NOT_CONTAINS) {\n    const rightValue = condition.rightValue as string;\n    return !leftValue.includes(rightValue);\n  }\n  if (operator === ConditionOperation.IN) {\n    const rightValue = condition.rightValue as string[];\n    return rightValue.includes(leftValue);\n  }\n  if (operator === ConditionOperation.NIN) {\n    const rightValue = condition.rightValue as string[];\n    return !rightValue.includes(leftValue);\n  }\n  if (operator === ConditionOperation.IS_EMPTY) {\n    return isNil(leftValue);\n  }\n  if (operator === ConditionOperation.IS_NOT_EMPTY) {\n    return !isNil(leftValue);\n  }\n  return false;\n};\n","import { isNil } from 'lodash-es';\n\nimport { ConditionHandler, ConditionOperation } from '../type';\n\nexport const conditionObjectHandler: ConditionHandler = (condition) => {\n  const { operator } = condition;\n  const leftValue = condition.leftValue as object;\n  // Switch case share scope, so we need to use if else here\n  if (operator === ConditionOperation.IS_EMPTY) {\n    return isNil(leftValue);\n  }\n  if (operator === ConditionOperation.IS_NOT_EMPTY) {\n    return !isNil(leftValue);\n  }\n  return false;\n};\n","import { isNil } from 'lodash-es';\n\nimport { ConditionHandler, ConditionOperation } from '../type';\n\nexport const conditionNumberHandler: ConditionHandler = (condition) => {\n  const { operator } = condition;\n  const leftValue = condition.leftValue as number;\n  // Switch case share scope, so we need to use if else here\n  if (operator === ConditionOperation.EQ) {\n    const rightValue = condition.rightValue as number;\n    return leftValue === rightValue;\n  }\n  if (operator === ConditionOperation.NEQ) {\n    const rightValue = condition.rightValue as number;\n    return leftValue !== rightValue;\n  }\n  if (operator === ConditionOperation.GT) {\n    const rightValue = condition.rightValue as number;\n    return leftValue > rightValue;\n  }\n  if (operator === ConditionOperation.GTE) {\n    const rightValue = condition.rightValue as number;\n    return leftValue >= rightValue;\n  }\n  if (operator === ConditionOperation.LT) {\n    const rightValue = condition.rightValue as number;\n    return leftValue < rightValue;\n  }\n  if (operator === ConditionOperation.LTE) {\n    const rightValue = condition.rightValue as number;\n    return leftValue <= rightValue;\n  }\n  if (operator === ConditionOperation.IN) {\n    const rightValue = condition.rightValue as number[];\n    return rightValue.includes(leftValue);\n  }\n  if (operator === ConditionOperation.NIN) {\n    const rightValue = condition.rightValue as number[];\n    return !rightValue.includes(leftValue);\n  }\n  if (operator === ConditionOperation.IS_EMPTY) {\n    return isNil(leftValue);\n  }\n  if (operator === ConditionOperation.IS_NOT_EMPTY) {\n    return !isNil(leftValue);\n  }\n  return false;\n};\n","import { isNil } from 'lodash-es';\n\nimport { ConditionHandler, ConditionOperation } from '../type';\n\nexport const conditionNullHandler: ConditionHandler = (condition) => {\n  const { operator } = condition;\n  const leftValue = condition.leftValue as unknown | null;\n  // Switch case share scope, so we need to use if else here\n  if (operator === ConditionOperation.EQ) {\n    return isNil(leftValue) && isNil(condition.rightValue);\n  }\n  if (operator === ConditionOperation.IS_EMPTY) {\n    return isNil(leftValue);\n  }\n  if (operator === ConditionOperation.IS_NOT_EMPTY) {\n    return !isNil(leftValue);\n  }\n  return false;\n};\n","import { isNil } from 'lodash-es';\n\nimport { ConditionHandler, ConditionOperation } from '../type';\n\nexport const conditionBooleanHandler: ConditionHandler = (condition) => {\n  const { operator } = condition;\n  const leftValue = condition.leftValue as boolean;\n  // Switch case share scope, so we need to use if else here\n  if (operator === ConditionOperation.EQ) {\n    const rightValue = condition.rightValue as boolean;\n    return leftValue === rightValue;\n  }\n  if (operator === ConditionOperation.NEQ) {\n    const rightValue = condition.rightValue as boolean;\n    return leftValue !== rightValue;\n  }\n  if (operator === ConditionOperation.IS_TRUE) {\n    return leftValue === true;\n  }\n  if (operator === ConditionOperation.IS_FALSE) {\n    return leftValue === false;\n  }\n  if (operator === ConditionOperation.IN) {\n    const rightValue = condition.rightValue as boolean[];\n    return rightValue.includes(leftValue);\n  }\n  if (operator === ConditionOperation.NIN) {\n    const rightValue = condition.rightValue as boolean[];\n    return !rightValue.includes(leftValue);\n  }\n  if (operator === ConditionOperation.IS_EMPTY) {\n    return isNil(leftValue);\n  }\n  if (operator === ConditionOperation.IS_NOT_EMPTY) {\n    return !isNil(leftValue);\n  }\n  return false;\n};\n","import { isNil } from 'lodash-es';\n\nimport { ConditionHandler, ConditionOperation } from '../type';\n\nexport const conditionArrayHandler: ConditionHandler = (condition) => {\n  const { operator } = condition;\n  const leftValue = condition.leftValue as object;\n  // Switch case share scope, so we need to use if else here\n  if (operator === ConditionOperation.IS_EMPTY) {\n    return isNil(leftValue);\n  }\n  if (operator === ConditionOperation.IS_NOT_EMPTY) {\n    return !isNil(leftValue);\n  }\n  return false;\n};\n","import { WorkflowVariableType } from '@flowgram.ai/runtime-interface';\n\nimport { ConditionHandlers } from '../type';\nimport { conditionStringHandler } from './string';\nimport { conditionObjectHandler } from './object';\nimport { conditionNumberHandler } from './number';\nimport { conditionNullHandler } from './null';\nimport { conditionBooleanHandler } from './boolean';\nimport { conditionArrayHandler } from './array';\n\nexport const conditionHandlers: ConditionHandlers = {\n  [WorkflowVariableType.String]: conditionStringHandler,\n  [WorkflowVariableType.Number]: conditionNumberHandler,\n  [WorkflowVariableType.Integer]: conditionNumberHandler,\n  [WorkflowVariableType.Boolean]: conditionBooleanHandler,\n  [WorkflowVariableType.Object]: conditionObjectHandler,\n  [WorkflowVariableType.Array]: conditionArrayHandler,\n  [WorkflowVariableType.Null]: conditionNullHandler,\n};\n","import { INodeExecutorFactory } from '@flowgram.ai/runtime-interface';\n\nimport { StartExecutor } from './start';\nimport { LoopExecutor } from './loop';\nimport { LLMExecutor } from './llm';\nimport { EndExecutor } from './end';\nimport { ConditionExecutor } from './condition';\n\nexport const WorkflowRuntimeNodeExecutors: INodeExecutorFactory[] = [\n  StartExecutor,\n  EndExecutor,\n  LLMExecutor,\n  ConditionExecutor,\n  LoopExecutor,\n];\n","import { WorkflowSchema, IValidation, ValidationResult } from '@flowgram.ai/runtime-interface';\n\nexport class WorkflowRuntimeValidation implements IValidation {\n  validate(schema: WorkflowSchema): ValidationResult {\n    // TODO\n    // 检查成环\n    // 检查边的节点是否存在\n    // 检查跨层级连线\n    // 检查是否只有一个开始节点和一个结束节点\n    // 检查开始节点是否在根节点\n    // 检查结束节点是否在根节点\n\n    // 注册节点检查器\n    return {\n      valid: true,\n    };\n  }\n}\n","import { FlowGramNode } from '@flowgram.ai/runtime-interface';\nimport {\n  ExecutionContext,\n  ExecutionResult,\n  IExecutor,\n  INodeExecutor,\n  INodeExecutorFactory,\n} from '@flowgram.ai/runtime-interface';\n\nexport class WorkflowRuntimeExecutor implements IExecutor {\n  private nodeExecutors: Map<FlowGramNode, INodeExecutor> = new Map();\n\n  constructor(nodeExecutors: INodeExecutorFactory[]) {\n    // register node executors\n    nodeExecutors.forEach((executor) => {\n      this.register(new executor());\n    });\n  }\n\n  public register(executor: INodeExecutor): void {\n    this.nodeExecutors.set(executor.type, executor);\n  }\n\n  public async execute(context: ExecutionContext): Promise<ExecutionResult> {\n    const nodeType = context.node.type;\n    const nodeExecutor = this.nodeExecutors.get(nodeType);\n    if (!nodeExecutor) {\n      throw new Error(`no executor found for node type ${nodeType}`);\n    }\n    const output = await nodeExecutor.execute(context);\n    return output;\n  }\n}\n","import { v4 } from 'uuid';\n\nexport const uuid = v4;\n","import { WorkflowVariableType } from '@flowgram.ai/runtime-interface';\n\nexport namespace WorkflowRuntimeType {\n  export const getWorkflowType = (value?: unknown): WorkflowVariableType | null => {\n    // 处理 null 和 undefined 的情况\n    if (value === null || value === undefined) {\n      return WorkflowVariableType.Null;\n    }\n\n    // 处理基本类型\n    if (typeof value === 'string') {\n      return WorkflowVariableType.String;\n    }\n\n    if (typeof value === 'boolean') {\n      return WorkflowVariableType.Boolean;\n    }\n\n    if (typeof value === 'number') {\n      if (Number.isInteger(value)) {\n        return WorkflowVariableType.Integer;\n      }\n      return WorkflowVariableType.Number;\n    }\n\n    // 处理数组\n    if (Array.isArray(value)) {\n      return WorkflowVariableType.Array;\n    }\n\n    // 处理普通对象\n    if (typeof value === 'object') {\n      return WorkflowVariableType.Object;\n    }\n\n    return null;\n  };\n\n  export const isMatchWorkflowType = (value: unknown, type: WorkflowVariableType): boolean => {\n    const workflowType = getWorkflowType(value);\n    if (!workflowType) {\n      return false;\n    }\n    return workflowType === type;\n  };\n\n  export const isTypeEqual = (\n    leftType: WorkflowVariableType,\n    rightType: WorkflowVariableType\n  ): boolean => {\n    // 处理 Number 和 Integer 等价的情况\n    if (\n      (leftType === WorkflowVariableType.Number && rightType === WorkflowVariableType.Integer) ||\n      (leftType === WorkflowVariableType.Integer && rightType === WorkflowVariableType.Number)\n    ) {\n      return true;\n    }\n    return leftType === rightType;\n  };\n}\n","import {\n  IContext,\n  ITask,\n  TaskParams,\n  WorkflowOutputs,\n  WorkflowStatus,\n} from '@flowgram.ai/runtime-interface';\n\nimport { uuid } from '@infra/utils';\n\nexport class WorkflowRuntimeTask implements ITask {\n  public readonly id: string;\n\n  public readonly processing: Promise<WorkflowOutputs>;\n\n  public readonly context: IContext;\n\n  constructor(params: TaskParams) {\n    this.id = uuid();\n    this.context = params.context;\n    this.processing = params.processing;\n  }\n\n  public cancel(): void {\n    this.context.statusCenter.workflow.cancel();\n    const cancelNodeIDs = this.context.statusCenter.getStatusNodeIDs(WorkflowStatus.Processing);\n    cancelNodeIDs.forEach((nodeID) => {\n      this.context.statusCenter.nodeStatus(nodeID).cancel();\n    });\n  }\n\n  public static create(params: TaskParams): WorkflowRuntimeTask {\n    return new WorkflowRuntimeTask(params);\n  }\n}\n","import { get, set } from 'lodash-es';\nimport {\n  WorkflowVariableType,\n  IVariableStore,\n  IVariable,\n  IVariableParseResult,\n} from '@flowgram.ai/runtime-interface';\n\nimport { uuid, WorkflowRuntimeType } from '@infra/utils';\nimport { WorkflowRuntimeVariable } from '../variable-value-object';\n\nexport class WorkflowRuntimeVariableStore implements IVariableStore {\n  public readonly id: string;\n\n  private parent?: WorkflowRuntimeVariableStore;\n\n  constructor() {\n    this.id = uuid();\n  }\n\n  public store: Map<string, Map<string, IVariable>>;\n\n  public init(): void {\n    this.store = new Map();\n  }\n\n  public dispose(): void {\n    this.store.clear();\n  }\n\n  public setParent(parent: IVariableStore): void {\n    this.parent = parent as WorkflowRuntimeVariableStore;\n  }\n\n  public globalGet(nodeID: string): Map<string, IVariable> | undefined {\n    const store = this.store.get(nodeID);\n    if (!store && this.parent) {\n      return this.parent.globalGet(nodeID);\n    }\n    return store;\n  }\n\n  public setVariable(params: {\n    nodeID: string;\n    key: string;\n    value: Object;\n    type: WorkflowVariableType;\n    itemsType?: WorkflowVariableType;\n  }): void {\n    const { nodeID, key, value, type, itemsType } = params;\n    if (!this.store.has(nodeID)) {\n      // create node store\n      this.store.set(nodeID, new Map());\n    }\n    const nodeStore = this.store.get(nodeID)!;\n    // create variable store\n    const variable = WorkflowRuntimeVariable.create({\n      nodeID,\n      key,\n      value,\n      type, // TODO check type\n      itemsType, // TODO check is array\n    });\n    nodeStore.set(key, variable);\n  }\n\n  public setValue(params: {\n    nodeID: string;\n    variableKey: string;\n    variablePath?: string[];\n    value: Object;\n  }): void {\n    const { nodeID, variableKey, variablePath, value } = params;\n    if (!this.store.has(nodeID)) {\n      // create node store\n      this.store.set(nodeID, new Map());\n    }\n    const nodeStore = this.store.get(nodeID)!;\n    if (!nodeStore.has(variableKey)) {\n      // create variable store\n      const variable = WorkflowRuntimeVariable.create({\n        nodeID,\n        key: variableKey,\n        value: {},\n        type: WorkflowVariableType.Object,\n      });\n      nodeStore.set(variableKey, variable);\n    }\n    const variable = nodeStore.get(variableKey)!;\n    if (!variablePath) {\n      variable.value = value;\n      return;\n    }\n    set(variable.value, variablePath, value);\n  }\n\n  public getValue<T = unknown>(params: {\n    nodeID: string;\n    variableKey: string;\n    variablePath?: string[];\n  }): IVariableParseResult<T> | null {\n    const { nodeID, variableKey, variablePath } = params;\n    const variable = this.globalGet(nodeID)?.get(variableKey);\n    if (!variable) {\n      return null;\n    }\n    if (!variablePath || variablePath.length === 0) {\n      return {\n        value: variable.value as T,\n        type: variable.type,\n        itemsType: variable.itemsType,\n      };\n    }\n    const value = get(variable.value, variablePath) as T;\n    const type = WorkflowRuntimeType.getWorkflowType(value);\n    if (!type) {\n      return null;\n    }\n    if (type === WorkflowVariableType.Array && Array.isArray(value)) {\n      const itemsType = WorkflowRuntimeType.getWorkflowType(value[0]);\n      if (!itemsType) {\n        return null;\n      }\n      return {\n        value,\n        type,\n        itemsType,\n      };\n    }\n    return {\n      value,\n      type,\n    };\n  }\n}\n","import { IVariable, VOData } from '@flowgram.ai/runtime-interface';\n\nimport { uuid } from '@infra/utils';\n\nexport namespace WorkflowRuntimeVariable {\n  export const create = (params: VOData<IVariable>): IVariable => ({\n    id: uuid(),\n    ...params,\n  });\n}\n","import { IStatus, StatusData, WorkflowStatus } from '@flowgram.ai/runtime-interface';\n\nimport { uuid } from '@infra/utils';\n\nexport class WorkflowRuntimeStatus implements IStatus {\n  public readonly id: string;\n\n  private _status: WorkflowStatus;\n\n  private _startTime: number;\n\n  private _endTime?: number;\n\n  constructor() {\n    this.id = uuid();\n    this._status = WorkflowStatus.Pending;\n  }\n\n  public get status(): WorkflowStatus {\n    return this._status;\n  }\n\n  public get terminated(): boolean {\n    return [WorkflowStatus.Succeeded, WorkflowStatus.Failed, WorkflowStatus.Canceled].includes(\n      this.status\n    );\n  }\n\n  public get startTime(): number {\n    return this._startTime;\n  }\n\n  public get endTime(): number | undefined {\n    return this._endTime;\n  }\n\n  public get timeCost(): number {\n    if (!this.startTime) {\n      return 0;\n    }\n    if (this.endTime) {\n      return this.endTime - this.startTime;\n    }\n    return Date.now() - this.startTime;\n  }\n\n  public process(): void {\n    this._status = WorkflowStatus.Processing;\n    this._startTime = Date.now();\n    this._endTime = undefined;\n  }\n\n  public success(): void {\n    if (this.terminated) {\n      return;\n    }\n    this._status = WorkflowStatus.Succeeded;\n    this._endTime = Date.now();\n  }\n\n  public fail(): void {\n    if (this.terminated) {\n      return;\n    }\n    this._status = WorkflowStatus.Failed;\n    this._endTime = Date.now();\n  }\n\n  public cancel(): void {\n    if (this.terminated) {\n      return;\n    }\n    this._status = WorkflowStatus.Canceled;\n    this._endTime = Date.now();\n  }\n\n  public export(): StatusData {\n    return {\n      status: this.status,\n      terminated: this.terminated,\n      startTime: this.startTime,\n      endTime: this.endTime,\n      timeCost: this.timeCost,\n    };\n  }\n\n  public static create(): WorkflowRuntimeStatus {\n    const status = new WorkflowRuntimeStatus();\n    return status;\n  }\n}\n","import { IStatus, IStatusCenter, StatusData, WorkflowStatus } from '@flowgram.ai/runtime-interface';\n\nimport { WorkflowRuntimeStatus } from '../status-entity';\n\nexport class WorkflowRuntimeStatusCenter implements IStatusCenter {\n  private _workflowStatus: IStatus;\n\n  private _nodeStatus: Map<string, IStatus>;\n\n  public startTime: number;\n\n  public endTime?: number;\n\n  public init(): void {\n    this._workflowStatus = WorkflowRuntimeStatus.create();\n    this._nodeStatus = new Map();\n  }\n\n  public dispose(): void {\n    // because the data is not persisted, do not clear the execution result\n  }\n\n  public get workflow(): IStatus {\n    return this._workflowStatus;\n  }\n\n  public get workflowStatus(): IStatus {\n    return this._workflowStatus;\n  }\n\n  public nodeStatus(nodeID: string): IStatus {\n    if (!this._nodeStatus.has(nodeID)) {\n      this._nodeStatus.set(nodeID, WorkflowRuntimeStatus.create());\n    }\n    const status = this._nodeStatus.get(nodeID)!;\n    return status;\n  }\n\n  public getStatusNodeIDs(status: WorkflowStatus): string[] {\n    return Array.from(this._nodeStatus.entries())\n      .filter(([, nodeStatus]) => nodeStatus.status === status)\n      .map(([nodeID]) => nodeID);\n  }\n\n  public exportNodeStatus(): Record<string, StatusData> {\n    return Object.fromEntries(\n      Array.from(this._nodeStatus.entries()).map(([nodeID, status]) => [nodeID, status.export()])\n    );\n  }\n}\n","import { isNil } from 'lodash-es';\nimport {\n  IState,\n  IFlowConstantRefValue,\n  IFlowRefValue,\n  IVariableParseResult,\n  INode,\n  WorkflowInputs,\n  WorkflowOutputs,\n  IVariableStore,\n  WorkflowVariableType,\n} from '@flowgram.ai/runtime-interface';\n\nimport { uuid, WorkflowRuntimeType } from '@infra/utils';\n\nexport class WorkflowRuntimeState implements IState {\n  public readonly id: string;\n\n  private executedNodes: Set<string>;\n\n  constructor(public readonly variableStore: IVariableStore) {\n    this.id = uuid();\n  }\n\n  public init(): void {\n    this.executedNodes = new Set();\n  }\n\n  public dispose(): void {\n    this.executedNodes.clear();\n  }\n\n  public getNodeInputs(node: INode): WorkflowInputs {\n    const inputsDeclare = node.declare.inputs;\n    const inputsValues = node.declare.inputsValues;\n    if (!inputsDeclare || !inputsValues) {\n      return {};\n    }\n    return Object.entries(inputsValues).reduce((prev, [key, inputValue]) => {\n      const typeInfo = inputsDeclare.properties?.[key];\n      if (!typeInfo) {\n        return prev;\n      }\n      const expectType = typeInfo.type as WorkflowVariableType;\n      // get value\n      const result = this.parseValue(inputValue);\n      if (!result) {\n        return prev;\n      }\n      const { value, type } = result;\n      if (!WorkflowRuntimeType.isTypeEqual(type, expectType)) {\n        return prev;\n      }\n      prev[key] = value;\n      return prev;\n    }, {} as WorkflowInputs);\n  }\n\n  public setNodeOutputs(params: { node: INode; outputs: WorkflowOutputs }): void {\n    const { node, outputs } = params;\n    const outputsDeclare = node.declare.outputs;\n    // TODO validation service type check, deeply compare input & schema\n    if (!outputsDeclare) {\n      return;\n    }\n    Object.entries(outputs).forEach(([key, value]) => {\n      const typeInfo = outputsDeclare.properties?.[key];\n      if (!typeInfo) {\n        return;\n      }\n      const type = typeInfo.type as WorkflowVariableType;\n      const itemsType = typeInfo.items?.type as WorkflowVariableType;\n      // create variable\n      this.variableStore.setVariable({\n        nodeID: node.id,\n        key,\n        value,\n        type,\n        itemsType,\n      });\n    });\n  }\n\n  public parseRef<T = unknown>(ref: IFlowRefValue): IVariableParseResult<T> | null {\n    if (ref?.type !== 'ref') {\n      throw new Error(`invalid ref value: ${ref}`);\n    }\n    if (!ref.content || ref.content.length < 2) {\n      return null;\n    }\n    const [nodeID, variableKey, ...variablePath] = ref.content;\n    const result = this.variableStore.getValue<T>({\n      nodeID,\n      variableKey,\n      variablePath,\n    });\n    if (!result) {\n      return null;\n    }\n    return result;\n  }\n\n  public parseValue<T = unknown>(flowValue: IFlowConstantRefValue): IVariableParseResult<T> | null {\n    if (!flowValue?.type) {\n      throw new Error(`invalid flow value type: ${(flowValue as any).type}`);\n    }\n    // constant\n    if (flowValue.type === 'constant') {\n      const value = flowValue.content as T;\n      const type = WorkflowRuntimeType.getWorkflowType(value);\n      if (isNil(value) || !type) {\n        return null;\n      }\n      return {\n        value,\n        type,\n      };\n    }\n    // ref\n    if (flowValue.type === 'ref') {\n      return this.parseRef<T>(flowValue);\n    }\n    // unknown type\n    throw new Error(`unknown flow value type: ${(flowValue as any).type}`);\n  }\n\n  public isExecutedNode(node: INode): boolean {\n    return this.executedNodes.has(node.id);\n  }\n\n  public addExecutedNode(node: INode): void {\n    this.executedNodes.add(node.id);\n  }\n}\n","import { ISnapshot, Snapshot, SnapshotData } from '@flowgram.ai/runtime-interface';\n\nimport { uuid } from '@infra/utils';\n\nexport class WorkflowRuntimeSnapshot implements ISnapshot {\n  public readonly id: string;\n\n  public readonly data: Partial<SnapshotData>;\n\n  public constructor(data: Partial<SnapshotData>) {\n    this.id = uuid();\n    this.data = data;\n  }\n\n  public addData(data: Partial<SnapshotData>): void {\n    Object.assign(this.data, data);\n  }\n\n  public validate(): boolean {\n    const required = ['nodeID', 'inputs', 'outputs', 'data'] as (keyof SnapshotData)[];\n    return required.every((key) => this.data[key] !== undefined);\n  }\n\n  public export(): Snapshot {\n    const snapshot: Snapshot = {\n      id: this.id,\n      ...this.data,\n    } as Snapshot;\n    return snapshot;\n  }\n\n  public static create(params: Partial<SnapshotData>): ISnapshot {\n    return new WorkflowRuntimeSnapshot(params);\n  }\n}\n","import { Snapshot, ISnapshotCenter, SnapshotData, ISnapshot } from '@flowgram.ai/runtime-interface';\n\nimport { uuid } from '@infra/utils';\nimport { WorkflowRuntimeSnapshot } from '../snapshot-entity';\n\nexport class WorkflowRuntimeSnapshotCenter implements ISnapshotCenter {\n  public readonly id: string;\n\n  private snapshots: ISnapshot[];\n\n  constructor() {\n    this.id = uuid();\n  }\n\n  public create(snapshotData: Partial<SnapshotData>): ISnapshot {\n    const snapshot = WorkflowRuntimeSnapshot.create(snapshotData);\n    this.snapshots.push(snapshot);\n    return snapshot;\n  }\n\n  public init(): void {\n    this.snapshots = [];\n  }\n\n  public dispose(): void {\n    // because the data is not persisted, do not clear the execution result\n  }\n\n  public exportAll(): Snapshot[] {\n    return this.snapshots.slice().map((snapshot) => snapshot.export());\n  }\n\n  public export(): Record<string, Snapshot[]> {\n    const result: Record<string, Snapshot[]> = {};\n    this.exportAll().forEach((snapshot) => {\n      if (result[snapshot.nodeID]) {\n        result[snapshot.nodeID].push(snapshot);\n      } else {\n        result[snapshot.nodeID] = [snapshot];\n      }\n    });\n    return result;\n  }\n}\n","import { IReport, VOData } from '@flowgram.ai/runtime-interface';\n\nimport { uuid } from '@infra/utils';\n\nexport namespace WorkflowRuntimeReport {\n  export const create = (params: VOData<IReport>): IReport => ({\n    id: uuid(),\n    ...params,\n  });\n}\n","import {\n  ISnapshotCenter,\n  IReporter,\n  IStatusCenter,\n  IIOCenter,\n  IReport,\n  NodeReport,\n} from '@flowgram.ai/runtime-interface';\n\nimport { WorkflowRuntimeReport } from '../report-value-object';\n\nexport class WorkflowRuntimeReporter implements IReporter {\n  constructor(\n    public readonly ioCenter: IIOCenter,\n    public readonly snapshotCenter: ISnapshotCenter,\n    public readonly statusCenter: IStatusCenter\n  ) {}\n\n  public init(): void {}\n\n  public dispose(): void {}\n\n  public export(): IReport {\n    const report = WorkflowRuntimeReport.create({\n      inputs: this.ioCenter.inputs,\n      outputs: this.ioCenter.outputs,\n      workflowStatus: this.statusCenter.workflow.export(),\n      reports: this.nodeReports(),\n    });\n    return report;\n  }\n\n  private nodeReports(): Record<string, NodeReport> {\n    const reports: Record<string, NodeReport> = {};\n    const statuses = this.statusCenter.exportNodeStatus();\n    const snapshots = this.snapshotCenter.export();\n    Object.keys(statuses).forEach((nodeID) => {\n      const status = statuses[nodeID];\n      const nodeSnapshots = snapshots[nodeID] || [];\n      const nodeReport: NodeReport = {\n        id: nodeID,\n        ...status,\n        snapshots: nodeSnapshots,\n      };\n      reports[nodeID] = nodeReport;\n    });\n    return reports;\n  }\n}\n","import { IIOCenter, IOData, WorkflowInputs, WorkflowOutputs } from '@flowgram.ai/runtime-interface';\n\nexport class WorkflowRuntimeIOCenter implements IIOCenter {\n  private _inputs: WorkflowInputs;\n\n  private _outputs: WorkflowOutputs;\n\n  public init(inputs: WorkflowInputs): void {\n    this.setInputs(inputs);\n  }\n\n  public dispose(): void {}\n\n  public get inputs(): WorkflowInputs {\n    return this._inputs ?? {};\n  }\n\n  public get outputs(): WorkflowOutputs {\n    return this._outputs ?? {};\n  }\n\n  public setInputs(inputs: WorkflowInputs): void {\n    this._inputs = inputs;\n  }\n\n  public setOutputs(outputs: WorkflowOutputs): void {\n    this._outputs = outputs;\n  }\n\n  public export(): IOData {\n    return {\n      inputs: this._inputs,\n      outputs: this._outputs,\n    };\n  }\n}\n","import {\n  WorkflowEdgeSchema,\n  CreateEdgeParams,\n  IEdge,\n  INode,\n  IPort,\n} from '@flowgram.ai/runtime-interface';\n\nexport class WorkflowRuntimeEdge implements IEdge {\n  public readonly id: string;\n\n  public readonly from: INode;\n\n  public readonly to: INode;\n\n  private _fromPort: IPort;\n\n  private _toPort: IPort;\n\n  constructor(params: CreateEdgeParams) {\n    const { id, from, to } = params;\n    this.id = id;\n    this.from = from;\n    this.to = to;\n  }\n\n  public get fromPort() {\n    return this._fromPort;\n  }\n\n  public set fromPort(port: IPort) {\n    this._fromPort = port;\n  }\n\n  public get toPort() {\n    return this._toPort;\n  }\n\n  public set toPort(port: IPort) {\n    this._toPort = port;\n  }\n\n  public static createID(schema: WorkflowEdgeSchema): string {\n    const { sourceNodeID, sourcePortID, targetNodeID, targetPortID } = schema;\n    const sourcePart = sourcePortID ? `${sourceNodeID}:${sourcePortID}` : sourceNodeID;\n    const targetPart = targetPortID ? `${targetNodeID}:${targetPortID}` : targetNodeID;\n    return `${sourcePart}-${targetPart}`;\n  }\n}\n","import {\n  FlowGramNode,\n  PositionSchema,\n  CreateNodeParams,\n  IEdge,\n  INode,\n  IPort,\n  NodeVariable,\n  WorkflowPortType,\n} from '@flowgram.ai/runtime-interface';\n\nexport class WorkflowRuntimeNode<T = any> implements INode {\n  public readonly id: string;\n\n  public readonly type: FlowGramNode;\n\n  public readonly name: string;\n\n  public readonly position: PositionSchema;\n\n  public readonly declare: NodeVariable;\n\n  public readonly data: T;\n\n  private _parent: INode | null;\n\n  private readonly _children: INode[];\n\n  private readonly _ports: IPort[];\n\n  private readonly _inputEdges: IEdge[];\n\n  private readonly _outputEdges: IEdge[];\n\n  private readonly _prev: INode[];\n\n  private readonly _next: INode[];\n\n  constructor(params: CreateNodeParams) {\n    const { id, type, name, position, variable, data } = params;\n    this.id = id;\n    this.type = type;\n    this.name = name;\n    this.position = position;\n    this.declare = variable ?? {};\n    this.data = data ?? {};\n    this._parent = null;\n    this._children = [];\n    this._ports = [];\n    this._inputEdges = [];\n    this._outputEdges = [];\n    this._prev = [];\n    this._next = [];\n  }\n\n  public get ports() {\n    const inputs = this._ports.filter((port) => port.type === WorkflowPortType.Input);\n    const outputs = this._ports.filter((port) => port.type === WorkflowPortType.Output);\n    return {\n      inputs,\n      outputs,\n    };\n  }\n\n  public get edges() {\n    return {\n      inputs: this._inputEdges,\n      outputs: this._outputEdges,\n    };\n  }\n\n  public get parent() {\n    return this._parent;\n  }\n\n  public set parent(parent: INode | null) {\n    this._parent = parent;\n  }\n\n  public get children() {\n    return this._children;\n  }\n\n  public addChild(child: INode) {\n    this._children.push(child);\n  }\n\n  public addPort(port: IPort) {\n    this._ports.push(port);\n  }\n\n  public addInputEdge(edge: IEdge) {\n    this._inputEdges.push(edge);\n    this._prev.push(edge.from);\n  }\n\n  public addOutputEdge(edge: IEdge) {\n    this._outputEdges.push(edge);\n    this._next.push(edge.to);\n  }\n\n  public get prev() {\n    return this._prev;\n  }\n\n  public get next() {\n    return this._next;\n  }\n\n  public get isBranch() {\n    return this.ports.outputs.length > 1;\n  }\n}\n","import {\n  WorkflowPortType,\n  CreatePortParams,\n  IEdge,\n  INode,\n  IPort,\n} from '@flowgram.ai/runtime-interface';\n\nexport class WorkflowRuntimePort implements IPort {\n  public readonly id: string;\n\n  public readonly node: INode;\n\n  public readonly type: WorkflowPortType;\n\n  private readonly _edges: IEdge[];\n\n  constructor(params: CreatePortParams) {\n    const { id, node } = params;\n    this.id = id;\n    this.node = node;\n    this.type = params.type;\n    this._edges = [];\n  }\n\n  public get edges() {\n    return this._edges;\n  }\n\n  public addEdge(edge: IEdge) {\n    this._edges.push(edge);\n  }\n}\n","import { WorkflowNodeSchema, WorkflowSchema, FlowGramNode } from '@flowgram.ai/runtime-interface';\n\nimport { WorkflowRuntimeEdge } from '../entity';\n\nexport interface FlattenData {\n  flattenSchema: WorkflowSchema;\n  nodeBlocks: Map<string, string[]>;\n  nodeEdges: Map<string, string[]>;\n}\n\ntype FlatSchema = (json: Partial<WorkflowSchema>) => FlattenData;\n\nconst flatLayer = (data: FlattenData, nodeSchema: WorkflowNodeSchema) => {\n  const { blocks, edges } = nodeSchema;\n  if (blocks) {\n    data.flattenSchema.nodes.push(...blocks);\n    const blockIDs: string[] = [];\n    blocks.forEach((block) => {\n      blockIDs.push(block.id);\n      // 递归处理子节点的 blocks 和 edges\n      if (block.blocks) {\n        flatLayer(data, block);\n      }\n    });\n    data.nodeBlocks.set(nodeSchema.id, blockIDs);\n    delete nodeSchema.blocks;\n  }\n  if (edges) {\n    data.flattenSchema.edges.push(...edges);\n    const edgeIDs: string[] = [];\n    edges.forEach((edge) => {\n      const edgeID = WorkflowRuntimeEdge.createID(edge);\n      edgeIDs.push(edgeID);\n    });\n    data.nodeEdges.set(nodeSchema.id, edgeIDs);\n    delete nodeSchema.edges;\n  }\n};\n\n/**\n * flat the tree json structure, extract the structure information to map\n */\nexport const flatSchema: FlatSchema = (schema = { nodes: [], edges: [] }) => {\n  const rootNodes = schema.nodes ?? [];\n  const rootEdges = schema.edges ?? [];\n\n  const data: FlattenData = {\n    flattenSchema: {\n      nodes: [],\n      edges: [],\n    },\n    nodeBlocks: new Map(),\n    nodeEdges: new Map(),\n  };\n\n  const root: WorkflowNodeSchema = {\n    id: FlowGramNode.Root,\n    type: FlowGramNode.Root,\n    blocks: rootNodes,\n    edges: rootEdges,\n    meta: {\n      position: {\n        x: 0,\n        y: 0,\n      },\n    },\n    data: {},\n  };\n\n  flatLayer(data, root);\n\n  return data;\n};\n","import {\n  FlowGramNode,\n  WorkflowPortType,\n  type CreateEdgeParams,\n  type CreateNodeParams,\n  type CreatePortParams,\n} from '@flowgram.ai/runtime-interface';\n\nimport { WorkflowRuntimeEdge, WorkflowRuntimeNode, WorkflowRuntimePort } from '../entity';\nimport { FlattenData } from './flat-schema';\n\nexport interface DocumentStore {\n  nodes: Map<string, WorkflowRuntimeNode>;\n  edges: Map<string, WorkflowRuntimeEdge>;\n  ports: Map<string, WorkflowRuntimePort>;\n}\n\nconst createNode = (store: DocumentStore, params: CreateNodeParams): WorkflowRuntimeNode => {\n  const node = new WorkflowRuntimeNode(params);\n  store.nodes.set(node.id, node);\n  return node;\n};\n\nconst createEdge = (store: DocumentStore, params: CreateEdgeParams): WorkflowRuntimeEdge => {\n  const edge = new WorkflowRuntimeEdge(params);\n  store.edges.set(edge.id, edge);\n  return edge;\n};\n\nconst getOrCreatePort = (store: DocumentStore, params: CreatePortParams): WorkflowRuntimePort => {\n  const createdPort = store.ports.get(params.id);\n  if (createdPort) {\n    return createdPort as WorkflowRuntimePort;\n  }\n  const port = new WorkflowRuntimePort(params);\n  store.ports.set(port.id, port);\n  return port;\n};\n\nexport const createStore = (params: FlattenData): DocumentStore => {\n  const { flattenSchema, nodeBlocks } = params;\n  const { nodes, edges } = flattenSchema;\n  const store: DocumentStore = {\n    nodes: new Map(),\n    edges: new Map(),\n    ports: new Map(),\n  };\n  // create root node\n  createNode(store, {\n    id: FlowGramNode.Root,\n    type: FlowGramNode.Root,\n    name: FlowGramNode.Root,\n    position: { x: 0, y: 0 },\n  });\n  // create nodes\n  nodes.forEach((nodeSchema) => {\n    const id = nodeSchema.id;\n    const type = nodeSchema.type as FlowGramNode;\n    const {\n      title = `${type}-${id}-untitled`,\n      inputsValues,\n      inputs,\n      outputs,\n      ...data\n    } = nodeSchema.data ?? {};\n    createNode(store, {\n      id,\n      type,\n      name: title,\n      position: nodeSchema.meta.position,\n      variable: { inputsValues, inputs, outputs },\n      data,\n    });\n  });\n  // create node relations\n  nodeBlocks.forEach((blockIDs, parentID) => {\n    const parent = store.nodes.get(parentID) as WorkflowRuntimeNode;\n    const children = blockIDs\n      .map((id) => store.nodes.get(id))\n      .filter(Boolean) as WorkflowRuntimeNode[];\n    children.forEach((child) => {\n      child.parent = parent;\n      parent.addChild(child);\n    });\n  });\n  // create edges & ports\n  edges.forEach((edgeSchema) => {\n    const id = WorkflowRuntimeEdge.createID(edgeSchema);\n    const {\n      sourceNodeID,\n      targetNodeID,\n      sourcePortID = 'defaultOutput',\n      targetPortID = 'defaultInput',\n    } = edgeSchema;\n    const from = store.nodes.get(sourceNodeID);\n    const to = store.nodes.get(targetNodeID);\n    if (!from || !to) {\n      throw new Error(`invalid edge schema ID: ${id}, from: ${sourceNodeID}, to: ${targetNodeID}`);\n    }\n    const edge = createEdge(store, {\n      id,\n      from,\n      to,\n    });\n\n    // create from port\n    const fromPort = getOrCreatePort(store, {\n      node: from,\n      id: sourcePortID,\n      type: WorkflowPortType.Output,\n    });\n\n    // build relation\n    fromPort.addEdge(edge);\n    edge.fromPort = fromPort;\n    from.addPort(fromPort);\n    from.addOutputEdge(edge);\n\n    // create to port\n    const toPort = getOrCreatePort(store, {\n      node: to,\n      id: targetPortID,\n      type: WorkflowPortType.Input,\n    });\n\n    // build relation\n    toPort.addEdge(edge);\n    edge.toPort = toPort;\n    to.addPort(toPort);\n    to.addInputEdge(edge);\n  });\n  return store;\n};\n","import {\n  type WorkflowSchema,\n  FlowGramNode,\n  type IDocument,\n  type IEdge,\n  type INode,\n} from '@flowgram.ai/runtime-interface';\n\nimport { uuid } from '@infra/utils';\nimport { flatSchema } from './flat-schema';\nimport { createStore, DocumentStore } from './create-store';\n\nexport class WorkflowRuntimeDocument implements IDocument {\n  public readonly id: string;\n\n  private store: DocumentStore;\n\n  constructor() {\n    this.id = uuid();\n  }\n\n  public get root(): INode {\n    const rootNode = this.getNode(FlowGramNode.Root);\n    if (!rootNode) {\n      throw new Error('Root node not found');\n    }\n    return rootNode;\n  }\n\n  public get start(): INode {\n    const startNode = this.nodes.find((n) => n.type === FlowGramNode.Start);\n    if (!startNode) {\n      throw new Error('Start node not found');\n    }\n    return startNode;\n  }\n\n  public get end(): INode {\n    const endNode = this.nodes.find((n) => n.type === FlowGramNode.End);\n    if (!endNode) {\n      throw new Error('End node not found');\n    }\n    return endNode;\n  }\n\n  public getNode(id: string): INode | null {\n    return this.store.nodes.get(id) ?? null;\n  }\n\n  public getEdge(id: string): IEdge | null {\n    return this.store.edges.get(id) ?? null;\n  }\n\n  public get nodes(): INode[] {\n    return Array.from(this.store.nodes.values());\n  }\n\n  public get edges(): IEdge[] {\n    return Array.from(this.store.edges.values());\n  }\n\n  public init(schema: WorkflowSchema): void {\n    const flattenSchema = flatSchema(schema);\n    this.store = createStore(flattenSchema);\n  }\n\n  public dispose(): void {\n    this.store.edges.clear();\n    this.store.nodes.clear();\n    this.store.ports.clear();\n  }\n}\n","import {\n  InvokeParams,\n  IContext,\n  IDocument,\n  IState,\n  ISnapshotCenter,\n  IVariableStore,\n  IStatusCenter,\n  IReporter,\n  IIOCenter,\n  ContextData,\n} from '@flowgram.ai/runtime-interface';\n\nimport { uuid } from '@infra/utils';\nimport { WorkflowRuntimeVariableStore } from '../variable';\nimport { WorkflowRuntimeStatusCenter } from '../status';\nimport { WorkflowRuntimeState } from '../state';\nimport { WorkflowRuntimeSnapshotCenter } from '../snapshot';\nimport { WorkflowRuntimeReporter } from '../report';\nimport { WorkflowRuntimeIOCenter } from '../io-center';\nimport { WorkflowRuntimeDocument } from '../document';\n\nexport class WorkflowRuntimeContext implements IContext {\n  public readonly id: string;\n\n  public readonly document: IDocument;\n\n  public readonly variableStore: IVariableStore;\n\n  public readonly state: IState;\n\n  public readonly ioCenter: IIOCenter;\n\n  public readonly snapshotCenter: ISnapshotCenter;\n\n  public readonly statusCenter: IStatusCenter;\n\n  public readonly reporter: IReporter;\n\n  private subContexts: IContext[] = [];\n\n  constructor(data: ContextData) {\n    this.id = uuid();\n    this.document = data.document;\n    this.variableStore = data.variableStore;\n    this.state = data.state;\n    this.ioCenter = data.ioCenter;\n    this.snapshotCenter = data.snapshotCenter;\n    this.statusCenter = data.statusCenter;\n    this.reporter = data.reporter;\n  }\n\n  public init(params: InvokeParams): void {\n    const { schema, inputs } = params;\n    this.document.init(schema);\n    this.variableStore.init();\n    this.state.init();\n    this.ioCenter.init(inputs);\n    this.snapshotCenter.init();\n    this.statusCenter.init();\n    this.reporter.init();\n  }\n\n  public dispose(): void {\n    this.subContexts.forEach((subContext) => {\n      subContext.dispose();\n    });\n    this.subContexts = [];\n    this.document.dispose();\n    this.variableStore.dispose();\n    this.state.dispose();\n    this.ioCenter.dispose();\n    this.snapshotCenter.dispose();\n    this.statusCenter.dispose();\n    this.reporter.dispose();\n  }\n\n  public sub(): IContext {\n    const variableStore = new WorkflowRuntimeVariableStore();\n    variableStore.setParent(this.variableStore);\n    const state = new WorkflowRuntimeState(variableStore);\n    const contextData: ContextData = {\n      document: this.document,\n      ioCenter: this.ioCenter,\n      snapshotCenter: this.snapshotCenter,\n      statusCenter: this.statusCenter,\n      reporter: this.reporter,\n      variableStore,\n      state,\n    };\n    const subContext = new WorkflowRuntimeContext(contextData);\n    this.subContexts.push(subContext);\n    subContext.variableStore.init();\n    subContext.state.init();\n    return subContext;\n  }\n\n  public static create(): IContext {\n    const document = new WorkflowRuntimeDocument();\n    const variableStore = new WorkflowRuntimeVariableStore();\n    const state = new WorkflowRuntimeState(variableStore);\n    const ioCenter = new WorkflowRuntimeIOCenter();\n    const snapshotCenter = new WorkflowRuntimeSnapshotCenter();\n    const statusCenter = new WorkflowRuntimeStatusCenter();\n    const reporter = new WorkflowRuntimeReporter(ioCenter, snapshotCenter, statusCenter);\n    return new WorkflowRuntimeContext({\n      document,\n      variableStore,\n      state,\n      ioCenter,\n      snapshotCenter,\n      statusCenter,\n      reporter,\n    });\n  }\n}\n","import {\n  EngineServices,\n  IEngine,\n  IExecutor,\n  INode,\n  WorkflowOutputs,\n  IContext,\n  InvokeParams,\n  ITask,\n  FlowGramNode,\n} from '@flowgram.ai/runtime-interface';\n\nimport { WorkflowRuntimeTask } from '../task';\nimport { WorkflowRuntimeContext } from '../context';\nimport { WorkflowRuntimeContainer } from '../container';\n\nexport class WorkflowRuntimeEngine implements IEngine {\n  private readonly executor: IExecutor;\n\n  constructor(service: EngineServices) {\n    this.executor = service.Executor;\n  }\n\n  public invoke(params: InvokeParams): ITask {\n    const context = WorkflowRuntimeContext.create();\n    context.init(params);\n    const processing = this.process(context);\n    processing.then(() => {\n      context.dispose();\n    });\n    return WorkflowRuntimeTask.create({\n      processing,\n      context,\n    });\n  }\n\n  public async executeNode(params: { context: IContext; node: INode }) {\n    const { node, context } = params;\n    if (!this.canExecuteNode({ node, context })) {\n      return;\n    }\n    context.statusCenter.nodeStatus(node.id).process();\n    try {\n      const inputs = context.state.getNodeInputs(node);\n      const snapshot = context.snapshotCenter.create({\n        nodeID: node.id,\n        data: node.data,\n        inputs,\n      });\n      const result = await this.executor.execute({\n        node,\n        inputs,\n        runtime: context,\n        container: WorkflowRuntimeContainer.instance,\n      });\n      if (context.statusCenter.workflow.terminated) {\n        return;\n      }\n      const { outputs, branch } = result;\n      snapshot.addData({ outputs, branch });\n      context.state.setNodeOutputs({ node, outputs });\n      context.state.addExecutedNode(node);\n      context.statusCenter.nodeStatus(node.id).success();\n      const nextNodes = this.getNextNodes({ node, branch, context });\n      await this.executeNext({ node, nextNodes, context });\n    } catch (e) {\n      context.statusCenter.nodeStatus(node.id).fail();\n      console.error(e);\n      return;\n    }\n  }\n\n  private async process(context: IContext): Promise<WorkflowOutputs> {\n    const startNode = context.document.start;\n    context.statusCenter.workflow.process();\n    try {\n      await this.executeNode({ node: startNode, context });\n      const outputs = context.ioCenter.outputs;\n      context.statusCenter.workflow.success();\n      return outputs;\n    } catch (e) {\n      context.statusCenter.workflow.fail();\n      throw e;\n    }\n  }\n\n  private canExecuteNode(params: { context: IContext; node: INode }) {\n    const { node, context } = params;\n    const prevNodes = node.prev;\n    if (prevNodes.length === 0) {\n      return true;\n    }\n    return prevNodes.every((prevNode) => context.state.isExecutedNode(prevNode));\n  }\n\n  private getNextNodes(params: { context: IContext; node: INode; branch?: string }) {\n    const { node, branch, context } = params;\n    const allNextNodes = node.next;\n    if (!branch) {\n      return allNextNodes;\n    }\n    const targetPort = node.ports.outputs.find((port) => port.id === branch);\n    if (!targetPort) {\n      throw new Error(`branch ${branch} not found`);\n    }\n    const nextNodeIDs: Set<string> = new Set(targetPort.edges.map((edge) => edge.to.id));\n    const nextNodes = allNextNodes.filter((nextNode) => nextNodeIDs.has(nextNode.id));\n    const skipNodes = allNextNodes.filter((nextNode) => !nextNodeIDs.has(nextNode.id));\n    skipNodes.forEach((skipNode) => {\n      context.state.addExecutedNode(skipNode);\n    });\n    return nextNodes;\n  }\n\n  private async executeNext(params: { context: IContext; node: INode; nextNodes: INode[] }) {\n    const { context, node, nextNodes } = params;\n    if (node.type === FlowGramNode.End) {\n      return;\n    }\n    if (nextNodes.length === 0) {\n      // throw new Error(`node ${node.id} has no next nodes`); // inside loop node may have no next nodes\n      return;\n    }\n    await Promise.all(\n      nextNodes.map((nextNode) =>\n        this.executeNode({\n          node: nextNode,\n          context,\n        })\n      )\n    );\n  }\n}\n","import {\n  ContainerService,\n  IContainer,\n  IEngine,\n  IExecutor,\n  IValidation,\n} from '@flowgram.ai/runtime-interface';\n\nimport { WorkflowRuntimeNodeExecutors } from '@nodes/index';\nimport { WorkflowRuntimeValidation } from '../validation';\nimport { WorkflowRuntimeExecutor } from '../executor';\nimport { WorkflowRuntimeEngine } from '../engine';\n\nexport class WorkflowRuntimeContainer implements IContainer {\n  constructor(private readonly services: Record<string, ContainerService>) {}\n\n  public get<T = ContainerService>(key: any): T {\n    return this.services[key] as T;\n  }\n\n  private static _instance: IContainer;\n\n  public static get instance(): IContainer {\n    if (this._instance) {\n      return this._instance;\n    }\n    const services = this.create();\n    this._instance = new WorkflowRuntimeContainer(services);\n    return this._instance;\n  }\n\n  private static create(): Record<symbol, ContainerService> {\n    // services\n    const Validation = new WorkflowRuntimeValidation();\n    const Executor = new WorkflowRuntimeExecutor(WorkflowRuntimeNodeExecutors);\n    const Engine = new WorkflowRuntimeEngine({\n      Executor,\n    });\n\n    return {\n      [IValidation]: Validation,\n      [IExecutor]: Executor,\n      [IEngine]: Engine,\n    };\n  }\n}\n","/* eslint-disable no-console */\nimport {\n  InvokeParams,\n  IContainer,\n  IEngine,\n  ITask,\n  IReport,\n  WorkflowOutputs,\n} from '@flowgram.ai/runtime-interface';\n\nimport { WorkflowRuntimeContainer } from '@workflow/container';\n\nexport class WorkflowApplication {\n  private container: IContainer;\n\n  public tasks: Map<string, ITask>;\n\n  constructor() {\n    this.container = WorkflowRuntimeContainer.instance;\n    this.tasks = new Map();\n  }\n\n  public run(params: InvokeParams): string {\n    const engine = this.container.get<IEngine>(IEngine);\n    const task = engine.invoke(params);\n    this.tasks.set(task.id, task);\n    console.log('> POST TaskRun - taskID: ', task.id);\n    console.log(params.inputs);\n    task.processing.then((output) => {\n      console.log('> LOG Task finished: ', task.id);\n      console.log(output);\n    });\n    return task.id;\n  }\n\n  public cancel(taskID: string): boolean {\n    console.log('> PUT TaskCancel - taskID: ', taskID);\n    const task = this.tasks.get(taskID);\n    if (!task) {\n      return false;\n    }\n    task.cancel();\n    return true;\n  }\n\n  public report(taskID: string): IReport | undefined {\n    const task = this.tasks.get(taskID);\n    console.log('> GET TaskReport - taskID: ', taskID);\n    if (!task) {\n      return;\n    }\n    return task.context.reporter.export();\n  }\n\n  public result(taskID: string): WorkflowOutputs | undefined {\n    console.log('> GET TaskResult - taskID: ', taskID);\n    const task = this.tasks.get(taskID);\n    if (!task) {\n      return;\n    }\n    if (!task.context.statusCenter.workflow.terminated) {\n      return;\n    }\n    return task.context.ioCenter.outputs;\n  }\n\n  private static _instance: WorkflowApplication;\n\n  public static get instance(): WorkflowApplication {\n    if (this._instance) {\n      return this._instance;\n    }\n    this._instance = new WorkflowApplication();\n    return this._instance;\n  }\n}\n","import { TaskRunInput, TaskRunOutput } from '@flowgram.ai/runtime-interface';\n\nimport { WorkflowApplication } from '@application/workflow';\n\nexport const TaskRunAPI = async (input: TaskRunInput): Promise<TaskRunOutput> => {\n  const app = WorkflowApplication.instance;\n  const { schema: stringSchema, inputs } = input;\n  const schema = JSON.parse(stringSchema);\n  const taskID = app.run({\n    schema,\n    inputs,\n  });\n  const output: TaskRunOutput = {\n    taskID,\n  };\n  return output;\n};\n","import { TaskResultInput, TaskResultOutput } from '@flowgram.ai/runtime-interface';\n\nimport { WorkflowApplication } from '@application/workflow';\n\nexport const TaskResultAPI = async (input: TaskResultInput): Promise<TaskResultOutput> => {\n  const app = WorkflowApplication.instance;\n  const { taskID } = input;\n  const output: TaskResultOutput = app.result(taskID);\n  return output;\n};\n","/* eslint-disable no-console */\nimport {\n  TaskReportInput,\n  TaskReportOutput,\n  TaskReportDefine,\n} from '@flowgram.ai/runtime-interface';\n\nimport { WorkflowApplication } from '@application/workflow';\n\nexport const TaskReportAPI = async (input: TaskReportInput): Promise<TaskReportOutput> => {\n  const app = WorkflowApplication.instance;\n  const { taskID } = input;\n  const output: TaskReportOutput = app.report(taskID);\n  try {\n    TaskReportDefine.schema.output.parse(output);\n  } catch (e) {\n    console.log('> TaskReportAPI - output: ', JSON.stringify(output));\n    console.error(e);\n  }\n  return output;\n};\n","import { TaskCancelInput, TaskCancelOutput } from '@flowgram.ai/runtime-interface';\n\nimport { WorkflowApplication } from '@application/workflow';\n\nexport const TaskCancelAPI = async (input: TaskCancelInput): Promise<TaskCancelOutput> => {\n  const app = WorkflowApplication.instance;\n  const { taskID } = input;\n  const success = app.cancel(taskID);\n  const output: TaskCancelOutput = {\n    success,\n  };\n  return output;\n};\n","import { FlowGramAPIName } from '@flowgram.ai/runtime-interface';\n\nimport { TaskRunAPI } from './task-run';\nimport { TaskResultAPI } from './task-result';\nimport { TaskReportAPI } from './task-report';\nimport { TaskCancelAPI } from './task-cancel';\n\nexport { TaskRunAPI, TaskResultAPI, TaskReportAPI, TaskCancelAPI };\n\nexport const WorkflowRuntimeAPIs: Record<FlowGramAPIName, (i: any) => any> = {\n  [FlowGramAPIName.TaskRun]: TaskRunAPI,\n  [FlowGramAPIName.TaskReport]: TaskReportAPI,\n  [FlowGramAPIName.TaskResult]: TaskResultAPI,\n  [FlowGramAPIName.TaskCancel]: TaskCancelAPI,\n  [FlowGramAPIName.ServerInfo]: () => {}, // TODO\n  [FlowGramAPIName.Validation]: () => {}, // TODO\n};\n"],"mappings":"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","names":["z","FlowGramAPIName","z","WorkflowPortType","WorkflowVariableType","FlowGramNode","WorkflowStatus","isNil","isNil","isNil","isNil","isNil","isNil","isNil","isNil","isNil","isNil","isNil","isNil","isNil","isNil","isNil","isNil","WorkflowRuntimeType","WorkflowRuntimeVariable","variable","isNil","isNil","WorkflowRuntimeReport"]}