import z from 'zod';

declare enum FlowGramAPIMethod {
    GET = "GET",
    POST = "POST",
    PUT = "PUT",
    DELETE = "DELETE",
    PATCH = "PATCH"
}
declare enum FlowGramAPIName {
    ServerInfo = "ServerInfo",
    TaskRun = "TaskRun",
    TaskReport = "TaskReport",
    TaskResult = "TaskResult",
    TaskCancel = "TaskCancel",
    Validation = "Validation"
}
declare enum FlowGramAPIModule {
    Info = "Info",
    Task = "Task",
    Validation = "Validation"
}

interface FlowGramAPIDefine {
    name: FlowGramAPIName;
    method: FlowGramAPIMethod;
    path: `/${string}`;
    module: FlowGramAPIModule;
    schema: {
        input: z.ZodFirstPartySchemaTypes;
        output: z.ZodFirstPartySchemaTypes;
    };
}
interface FlowGramAPIDefines {
    [key: string]: FlowGramAPIDefine;
}

declare const FlowGramAPIs: FlowGramAPIDefines;
declare const FlowGramAPINames: FlowGramAPIName[];

type ContainerService = any;
interface IContainer {
    get<T = ContainerService>(key: any): T;
}

type VOData<T> = Omit<T, 'id'>;

interface WorkflowEdgeSchema {
    sourceNodeID: string;
    targetNodeID: string;
    sourcePortID?: string;
    targetPortID?: string;
}

type JsonSchemaBasicType = 'boolean' | 'string' | 'integer' | 'number' | 'object' | 'array' | 'map';
interface IJsonSchema<T = string> {
    type: T;
    default?: any;
    title?: string;
    description?: string;
    enum?: (string | number)[];
    properties?: Record<string, IJsonSchema<T>>;
    additionalProperties?: IJsonSchema<T>;
    items?: IJsonSchema<T>;
    required?: string[];
    $ref?: string;
    extra?: {
        index?: number;
        weak?: boolean;
        formComponent?: string;
        [key: string]: any;
    };
}
type IBasicJsonSchema = IJsonSchema<JsonSchemaBasicType>;

interface XYSchema {
    x: number;
    y: number;
}
type PositionSchema = XYSchema;

interface WorkflowNodeMetaSchema {
    position: PositionSchema;
    canvasPosition?: PositionSchema;
}

interface IFlowConstantValue {
    type: 'constant';
    content?: string | number | boolean;
}
interface IFlowRefValue {
    type: 'ref';
    content?: string[];
}
type IFlowConstantRefValue = IFlowConstantValue | IFlowRefValue;

interface WorkflowNodeSchema<T = string, D = any> {
    id: string;
    type: T;
    meta: WorkflowNodeMetaSchema;
    data: D & {
        title?: string;
        inputsValues?: Record<string, IFlowConstantRefValue>;
        inputs?: IJsonSchema;
        outputs?: IJsonSchema;
        [key: string]: any;
    };
    blocks?: WorkflowNodeSchema[];
    edges?: WorkflowEdgeSchema[];
}

interface WorkflowSchema {
    nodes: WorkflowNodeSchema[];
    edges: WorkflowEdgeSchema[];
}

declare enum WorkflowPortType {
    Input = "input",
    Output = "output"
}
declare enum WorkflowVariableType {
    String = "string",
    Integer = "integer",
    Number = "number",
    Boolean = "boolean",
    Object = "object",
    Array = "array",
    Null = "null"
}

type WorkflowInputs = Record<string, any>;
type WorkflowOutputs = Record<string, any>;

interface InvokeParams {
    schema: WorkflowSchema;
    inputs: WorkflowInputs;
}
type WorkflowRuntimeInvoke = (params: InvokeParams) => Promise<WorkflowInputs>;

interface VariableTypeInfo {
    type: WorkflowVariableType;
    itemsType?: WorkflowVariableType;
}
interface IVariable<T = Object> extends VariableTypeInfo {
    id: string;
    nodeID: string;
    key: string;
    value: T;
}
interface IVariableParseResult<T = unknown> extends VariableTypeInfo {
    value: T;
    type: WorkflowVariableType;
}
interface IVariableStore {
    id: string;
    store: Map<string, Map<string, IVariable>>;
    setParent(parent: IVariableStore): void;
    setVariable(params: {
        nodeID: string;
        key: string;
        value: Object;
    } & VariableTypeInfo): void;
    setValue(params: {
        nodeID: string;
        variableKey: string;
        variablePath?: string[];
        value: Object;
    }): void;
    getValue<T = unknown>(params: {
        nodeID: string;
        variableKey: string;
        variablePath?: string[];
    }): IVariableParseResult<T> | null;
    init(): void;
    dispose(): void;
}

declare enum WorkflowStatus {
    Pending = "pending",
    Processing = "processing",
    Succeeded = "succeeded",
    Failed = "failed",
    Canceled = "canceled"
}
interface StatusData {
    status: WorkflowStatus;
    terminated: boolean;
    startTime: number;
    endTime?: number;
    timeCost: number;
}
interface IStatus extends StatusData {
    id: string;
    process(): void;
    success(): void;
    fail(): void;
    cancel(): void;
    export(): StatusData;
}
interface IStatusCenter {
    workflow: IStatus;
    nodeStatus(nodeID: string): IStatus;
    init(): void;
    dispose(): void;
    getStatusNodeIDs(status: WorkflowStatus): string[];
    exportNodeStatus(): Record<string, StatusData>;
}

interface SnapshotData {
    nodeID: string;
    inputs: WorkflowInputs;
    outputs: WorkflowOutputs;
    data: any;
    branch?: string;
}
interface Snapshot extends SnapshotData {
    id: string;
}
interface ISnapshot {
    id: string;
    data: Partial<SnapshotData>;
    addData(data: Partial<SnapshotData>): void;
    validate(): boolean;
    export(): Snapshot;
}

interface ISnapshotCenter {
    id: string;
    create(snapshot: Partial<SnapshotData>): ISnapshot;
    exportAll(): Snapshot[];
    export(): Record<string, Snapshot[]>;
    init(): void;
    dispose(): void;
}

interface IOData {
    inputs: WorkflowInputs;
    outputs: WorkflowOutputs;
}
/** Input & Output */
interface IIOCenter {
    inputs: WorkflowInputs;
    outputs: WorkflowOutputs;
    setInputs(inputs: WorkflowInputs): void;
    setOutputs(outputs: WorkflowOutputs): void;
    init(inputs: WorkflowInputs): void;
    dispose(): void;
    export(): IOData;
}

declare enum FlowGramNode {
    Root = "root",
    Start = "start",
    End = "end",
    LLM = "llm",
    code = "code",
    Condition = "condition",
    Loop = "loop",
    Comment = "comment",
    Group = "group"
}

interface IEdge {
    id: string;
    from: INode;
    to: INode;
    fromPort: IPort;
    toPort: IPort;
}
interface CreateEdgeParams {
    id: string;
    from: INode;
    to: INode;
}

interface IPort {
    id: string;
    node: INode;
    edges: IEdge[];
    type: WorkflowPortType;
}
interface CreatePortParams {
    id: string;
    node: INode;
    type: WorkflowPortType;
}

interface NodeDeclare {
    inputsValues?: Record<string, IFlowConstantRefValue>;
    inputs?: IJsonSchema;
    outputs?: IJsonSchema;
}
interface INode<T = any> {
    id: string;
    type: FlowGramNode;
    name: string;
    position: PositionSchema;
    declare: NodeDeclare;
    data: T;
    ports: {
        inputs: IPort[];
        outputs: IPort[];
    };
    edges: {
        inputs: IEdge[];
        outputs: IEdge[];
    };
    parent: INode | null;
    children: INode[];
    prev: INode[];
    next: INode[];
    isBranch: boolean;
}
interface CreateNodeParams {
    id: string;
    type: FlowGramNode;
    name: string;
    position: PositionSchema;
    variable?: NodeDeclare;
    data?: any;
}

interface IDocument {
    id: string;
    nodes: INode[];
    edges: IEdge[];
    root: INode;
    start: INode;
    end: INode;
    init(schema: WorkflowSchema): void;
    dispose(): void;
}

interface IState {
    id: string;
    variableStore: IVariableStore;
    init(): void;
    dispose(): void;
    getNodeInputs(node: INode): WorkflowInputs;
    setNodeOutputs(params: {
        node: INode;
        outputs: WorkflowOutputs;
    }): void;
    parseRef<T = unknown>(ref: IFlowRefValue): IVariableParseResult<T> | null;
    parseValue<T = unknown>(flowValue: IFlowConstantRefValue, type?: WorkflowVariableType): IVariableParseResult<T> | null;
    isExecutedNode(node: INode): boolean;
    addExecutedNode(node: INode): void;
}

interface NodeReport extends StatusData {
    id: string;
    snapshots: Snapshot[];
}
interface IReport {
    id: string;
    inputs: WorkflowInputs;
    outputs: WorkflowOutputs;
    workflowStatus: StatusData;
    reports: Record<string, NodeReport>;
}
interface IReporter {
    snapshotCenter: ISnapshotCenter;
    statusCenter: IStatusCenter;
    init(): void;
    dispose(): void;
    export(): IReport;
}

interface ContextData {
    variableStore: IVariableStore;
    state: IState;
    document: IDocument;
    ioCenter: IIOCenter;
    snapshotCenter: ISnapshotCenter;
    statusCenter: IStatusCenter;
    reporter: IReporter;
}
interface IContext extends ContextData {
    id: string;
    init(params: InvokeParams): void;
    dispose(): void;
    sub(): IContext;
}

interface ITask {
    id: string;
    processing: Promise<WorkflowOutputs>;
    context: IContext;
    cancel(): void;
}
interface TaskParams {
    processing: Promise<WorkflowOutputs>;
    context: IContext;
}

interface EndNodeData {
    title: string;
    inputs: IJsonSchema<'object'>;
    outputs: IJsonSchema<'object'>;
    outputValues: Record<string, IFlowConstantRefValue>;
}
type EndNodeSchema = WorkflowNodeSchema<FlowGramNode.End, EndNodeData>;

interface LLMNodeData {
    title: string;
    inputs: IJsonSchema<'object'>;
    outputs: IJsonSchema<'object'>;
    inputValues: {
        apiKey: IFlowConstantRefValue;
        modelType: IFlowConstantRefValue;
        baseURL: IFlowConstantRefValue;
        temperature: IFlowConstantRefValue;
        systemPrompt: IFlowConstantRefValue;
        prompt: IFlowConstantRefValue;
    };
}
type LLMNodeSchema = WorkflowNodeSchema<FlowGramNode.LLM, LLMNodeData>;

interface StartNodeData {
    title: string;
    outputs: IJsonSchema<'object'>;
}
type StartNodeSchema = WorkflowNodeSchema<FlowGramNode.Start, StartNodeData>;

interface ExecutionContext {
    node: INode;
    inputs: WorkflowInputs;
    container: IContainer;
    runtime: IContext;
}
interface ExecutionResult {
    outputs: WorkflowOutputs;
    branch?: string;
}
interface INodeExecutor {
    type: FlowGramNode;
    execute: (context: ExecutionContext) => Promise<ExecutionResult>;
}
interface INodeExecutorFactory {
    new (): INodeExecutor;
}

interface IExecutor {
    execute: (context: ExecutionContext) => Promise<ExecutionResult>;
    register: (executor: INodeExecutor) => void;
}
declare const IExecutor: unique symbol;

interface EngineServices {
    Executor: IExecutor;
}
interface IEngine {
    invoke(params: InvokeParams): ITask;
    executeNode(params: {
        context: IContext;
        node: INode;
    }): Promise<void>;
}
declare const IEngine: unique symbol;

interface ValidationResult {
    valid: boolean;
    errors?: string[];
}
interface IValidation {
    validate(schema: WorkflowSchema): ValidationResult;
}
declare const IValidation: unique symbol;

interface TaskRunInput {
    inputs: WorkflowInputs;
    schema: string;
}
interface TaskRunOutput {
    taskID: string;
}
declare const TaskRunDefine: FlowGramAPIDefine;

interface ServerInfoInput {
}
interface ServerInfoOutput {
    name: string;
    title: string;
    description: string;
    runtime: string;
    version: string;
    time: string;
}
declare const ServerInfoDefine: FlowGramAPIDefine;

interface TaskReportInput {
    taskID: string;
}
type TaskReportOutput = IReport | undefined;
declare const TaskReportDefine: FlowGramAPIDefine;

interface ValidationReq {
    schema: string;
}
interface ValidationRes extends ValidationResult {
}
declare const ValidationDefine: FlowGramAPIDefine;

interface TaskResultInput {
    taskID: string;
}
type TaskResultOutput = WorkflowOutputs | undefined;
declare const TaskResultDefine: FlowGramAPIDefine;

interface TaskCancelInput {
    taskID: string;
}
type TaskCancelOutput = {
    success: boolean;
};
declare const TaskCancelDefine: FlowGramAPIDefine;

interface IRuntimeClient {
    [FlowGramAPIName.TaskRun]: (input: TaskRunInput) => Promise<TaskRunOutput | undefined>;
    [FlowGramAPIName.TaskReport]: (input: TaskReportInput) => Promise<TaskReportOutput | undefined>;
    [FlowGramAPIName.TaskResult]: (input: TaskResultInput) => Promise<TaskResultOutput | undefined>;
    [FlowGramAPIName.TaskCancel]: (input: TaskCancelInput) => Promise<TaskCancelOutput | undefined>;
}

export { type ContainerService, type ContextData, type CreateEdgeParams, type CreateNodeParams, type CreatePortParams, type EndNodeSchema, type EngineServices, type ExecutionContext, type ExecutionResult, type FlowGramAPIDefine, type FlowGramAPIDefines, FlowGramAPIMethod, FlowGramAPIModule, FlowGramAPIName, FlowGramAPINames, FlowGramAPIs, FlowGramNode, type IBasicJsonSchema, type IContainer, type IContext, type IDocument, type IEdge, IEngine, IExecutor, type IFlowConstantRefValue, type IFlowConstantValue, type IFlowRefValue, type IIOCenter, type IJsonSchema, type INode, type INodeExecutor, type INodeExecutorFactory, type IOData, type IPort, type IReport, type IReporter, type IRuntimeClient, type ISnapshot, type ISnapshotCenter, type IState, type IStatus, type IStatusCenter, type ITask, IValidation, type IVariable, type IVariableParseResult, type IVariableStore, type InvokeParams, type JsonSchemaBasicType, type LLMNodeSchema, type NodeReport, type NodeDeclare as NodeVariable, type PositionSchema, ServerInfoDefine, type ServerInfoInput, type ServerInfoOutput, type Snapshot, type SnapshotData, type StartNodeSchema, type StatusData, TaskCancelDefine, type TaskCancelInput, type TaskCancelOutput, type TaskParams, TaskReportDefine, type TaskReportInput, type TaskReportOutput, TaskResultDefine, type TaskResultInput, type TaskResultOutput, TaskRunDefine, type TaskRunInput, type TaskRunOutput, type VOData, ValidationDefine, type ValidationReq, type ValidationRes, type ValidationResult, type WorkflowEdgeSchema, type WorkflowInputs, type WorkflowNodeMetaSchema, type WorkflowNodeSchema, type WorkflowOutputs, WorkflowPortType, type WorkflowRuntimeInvoke, type WorkflowSchema, WorkflowStatus, WorkflowVariableType, type XYSchema };
