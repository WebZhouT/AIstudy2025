"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BackgroundConfig: () => BackgroundConfig,
  BackgroundLayer: () => BackgroundLayer,
  createBackgroundPlugin: () => createBackgroundPlugin
});
module.exports = __toCommonJS(src_exports);

// src/background-layer.tsx
var import_utils = require("@flowgram.ai/utils");
var import_core = require("@flowgram.ai/core");
var PATTERN_PREFIX = "gedit-background-pattern-";
var DEFAULT_RENDER_SIZE = 20;
var DEFAULT_DOT_SIZE = 1;
var id = 0;
var BackgroundConfig = Symbol("BackgroundConfig");
var BackgroundLayer = class extends import_core.Layer {
  constructor() {
    super(...arguments);
    this._patternId = `${PATTERN_PREFIX}${id++}`;
    this.node = import_utils.domUtils.createDivWithClass("gedit-flow-background-layer");
    this.grid = document.createElement("div");
  }
  /**
   * 获取网格大小配置
   */
  get gridSize() {
    return this.options.gridSize ?? DEFAULT_RENDER_SIZE;
  }
  /**
   * 获取点大小配置
   */
  get dotSize() {
    return this.options.dotSize ?? DEFAULT_DOT_SIZE;
  }
  /**
   * 获取点颜色配置
   */
  get dotColor() {
    return this.options.dotColor ?? "#eceeef";
  }
  /**
   * 获取点透明度配置
   */
  get dotOpacity() {
    return this.options.dotOpacity ?? 0.5;
  }
  /**
   * 获取背景颜色配置
   */
  get backgroundColor() {
    return this.options.backgroundColor ?? "transparent";
  }
  /**
   * 获取点填充颜色配置
   */
  get dotFillColor() {
    return this.options.dotFillColor ?? this.dotColor;
  }
  /**
   * 获取Logo配置
   */
  get logoConfig() {
    return this.options.logo;
  }
  /**
   * 当前缩放比
   */
  get zoom() {
    return this.config.finalScale;
  }
  onReady() {
    const { firstChild } = this.pipelineNode;
    this.pipelineNode.insertBefore(this.node, firstChild);
    this.playgroundConfigEntity.updateConfig({
      minZoom: 0.1,
      maxZoom: 2
    });
    this.grid.style.zIndex = "-1";
    this.grid.style.position = "relative";
    this.node.appendChild(this.grid);
    this.grid.className = "gedit-grid-svg";
    if (this.backgroundColor !== "transparent") {
      this.node.style.backgroundColor = this.backgroundColor;
    }
  }
  /**
   * 最小单元格大小
   */
  getScaleUnit() {
    const { zoom } = this;
    return {
      realSize: this.gridSize,
      // 使用配置的网格大小
      renderSize: Math.round(this.gridSize * zoom * 100) / 100,
      // 一个单元格渲染的大小值
      zoom
      // 缩放比
    };
  }
  /**
   * 绘制
   */
  autorun() {
    const playgroundConfig = this.playgroundConfigEntity.config;
    const scaleUnit = this.getScaleUnit();
    const mod = scaleUnit.renderSize * 10;
    const viewBoxWidth = playgroundConfig.width + mod * 2;
    const viewBoxHeight = playgroundConfig.height + mod * 2;
    const { scrollX } = playgroundConfig;
    const { scrollY } = playgroundConfig;
    const scrollXDelta = this.getScrollDelta(scrollX, mod);
    const scrollYDelta = this.getScrollDelta(scrollY, mod);
    import_utils.domUtils.setStyle(this.node, {
      left: scrollX - import_core.SCALE_WIDTH,
      top: scrollY - import_core.SCALE_WIDTH
    });
    this.drawGrid(scaleUnit, viewBoxWidth, viewBoxHeight);
    this.setSVGStyle(this.grid, {
      width: viewBoxWidth,
      height: viewBoxHeight,
      left: import_core.SCALE_WIDTH - scrollXDelta - mod,
      top: import_core.SCALE_WIDTH - scrollYDelta - mod
    });
  }
  /**
   * 计算Logo位置
   */
  calculateLogoPosition(viewBoxWidth, viewBoxHeight) {
    if (!this.logoConfig) return { x: 0, y: 0 };
    const { position = "center", offset = { x: 0, y: 0 } } = this.logoConfig;
    const playgroundConfig = this.playgroundConfigEntity.config;
    const scaleUnit = this.getScaleUnit();
    const mod = scaleUnit.renderSize * 10;
    const { scrollX, scrollY } = playgroundConfig;
    const scrollXDelta = this.getScrollDelta(scrollX, mod);
    const scrollYDelta = this.getScrollDelta(scrollY, mod);
    const visibleLeft = mod + scrollXDelta;
    const visibleTop = mod + scrollYDelta;
    const visibleCenterX = visibleLeft + playgroundConfig.width / 2;
    const visibleCenterY = visibleTop + playgroundConfig.height / 2;
    let x = 0, y = 0;
    switch (position) {
      case "center":
        x = visibleCenterX;
        y = visibleCenterY;
        break;
      case "top-left":
        x = visibleLeft + 100;
        y = visibleTop + 100;
        break;
      case "top-right":
        x = visibleLeft + playgroundConfig.width - 100;
        y = visibleTop + 100;
        break;
      case "bottom-left":
        x = visibleLeft + 100;
        y = visibleTop + playgroundConfig.height - 100;
        break;
      case "bottom-right":
        x = visibleLeft + playgroundConfig.width - 100;
        y = visibleTop + playgroundConfig.height - 100;
        break;
    }
    return { x: x + offset.x, y: y + offset.y };
  }
  /**
   * 获取Logo大小
   */
  getLogoSize() {
    if (!this.logoConfig) return 0;
    const { size = "medium" } = this.logoConfig;
    if (typeof size === "number") {
      return size;
    }
    switch (size) {
      case "small":
        return 24;
      case "medium":
        return 48;
      case "large":
        return 72;
      default:
        return 48;
    }
  }
  /**
   * 颜色工具函数：将十六进制颜色转换为RGB
   */
  hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  }
  /**
   * 颜色工具函数：调整颜色亮度
   */
  adjustBrightness(hex, percent) {
    const rgb = this.hexToRgb(hex);
    if (!rgb) return hex;
    const adjust = (value) => {
      const adjusted = Math.round(value + (255 - value) * percent);
      return Math.max(0, Math.min(255, adjusted));
    };
    return `#${adjust(rgb.r).toString(16).padStart(2, "0")}${adjust(rgb.g).toString(16).padStart(2, "0")}${adjust(rgb.b).toString(16).padStart(2, "0")}`;
  }
  /**
   * 生成新拟态阴影滤镜
   */
  generateNeumorphismFilter(filterId, lightShadow, darkShadow, offset, blur, intensity, raised) {
    const lightOffset = raised ? -offset : offset;
    const darkOffset = raised ? offset : -offset;
    return `
      <defs>
        <filter id="${filterId}" x="-50%" y="-50%" width="200%" height="200%">
          <feDropShadow dx="${lightOffset}" dy="${lightOffset}" stdDeviation="${blur}" flood-color="${lightShadow}" flood-opacity="${intensity}"/>
          <feDropShadow dx="${darkOffset}" dy="${darkOffset}" stdDeviation="${blur}" flood-color="${darkShadow}" flood-opacity="${intensity}"/>
        </filter>
      </defs>`;
  }
  /**
   * 绘制Logo SVG内容
   */
  generateLogoSVG(viewBoxWidth, viewBoxHeight) {
    if (!this.logoConfig) return "";
    const {
      text,
      imageUrl,
      opacity = 0.1,
      color = "#cccccc",
      fontSize,
      fontFamily = "Arial, sans-serif",
      fontWeight = "normal",
      neumorphism
    } = this.logoConfig;
    const position = this.calculateLogoPosition(viewBoxWidth, viewBoxHeight);
    const logoSize = this.getLogoSize();
    let logoSVG = "";
    if (imageUrl) {
      logoSVG = `
        <image
          href="${imageUrl}"
          x="${position.x - logoSize / 2}"
          y="${position.y - logoSize / 2}"
          width="${logoSize}"
          height="${logoSize}"
          opacity="${opacity}"
        />`;
    } else if (text) {
      const actualFontSize = fontSize ?? Math.max(logoSize / 2, 12);
      if (neumorphism?.enabled) {
        const {
          textColor,
          lightShadowColor,
          darkShadowColor,
          shadowOffset = 6,
          shadowBlur = 12,
          intensity = 0.3,
          raised = true
        } = neumorphism;
        const bgColor = this.backgroundColor !== "transparent" ? this.backgroundColor : "#f0f0f0";
        const finalTextColor = textColor || bgColor;
        const finalLightShadow = lightShadowColor || this.adjustBrightness(bgColor, 0.2);
        const finalDarkShadow = darkShadowColor || this.adjustBrightness(bgColor, -0.2);
        const filterId = `neumorphism-${this._patternId}`;
        logoSVG += this.generateNeumorphismFilter(
          filterId,
          finalLightShadow,
          finalDarkShadow,
          shadowOffset,
          shadowBlur,
          intensity,
          raised
        );
        logoSVG += `
          <text
            x="${position.x}"
            y="${position.y}"
            font-family="${fontFamily}"
            font-size="${actualFontSize}"
            font-weight="${fontWeight}"
            fill="${finalTextColor}"
            opacity="${opacity}"
            text-anchor="middle"
            dominant-baseline="middle"
            filter="url(#${filterId})"
          >${text}</text>`;
      } else {
        logoSVG = `
          <text
            x="${position.x}"
            y="${position.y}"
            font-family="${fontFamily}"
            font-size="${actualFontSize}"
            font-weight="${fontWeight}"
            fill="${color}"
            opacity="${opacity}"
            text-anchor="middle"
            dominant-baseline="middle"
          >${text}</text>`;
      }
    }
    return logoSVG;
  }
  /**
   * 绘制网格
   */
  drawGrid(unit, viewBoxWidth, viewBoxHeight) {
    const minor = unit.renderSize;
    if (!this.grid) {
      return;
    }
    const patternSize = this.dotSize * this.zoom;
    let svgContent = `<svg width="100%" height="100%">`;
    if (this.backgroundColor !== "transparent") {
      svgContent += `<rect width="100%" height="100%" fill="${this.backgroundColor}"/>`;
    }
    const circleAttributes = [
      `cx="${patternSize}"`,
      `cy="${patternSize}"`,
      `r="${patternSize}"`,
      `stroke="${this.dotColor}"`,
      // 只有当 dotFillColor 被明确设置且与 dotColor 不同时才添加 fill 属性
      this.options.dotFillColor && this.dotFillColor !== this.dotColor ? `fill="${this.dotFillColor}"` : "",
      `fill-opacity="${this.dotOpacity}"`
    ].filter(Boolean).join(" ");
    svgContent += `
      <pattern id="${this._patternId}" width="${minor}" height="${minor}" patternUnits="userSpaceOnUse">
        <circle ${circleAttributes} />
      </pattern>
      <rect width="100%" height="100%" fill="url(#${this._patternId})"/>`;
    const logoSVG = this.generateLogoSVG(viewBoxWidth, viewBoxHeight);
    if (logoSVG) {
      svgContent += logoSVG;
    }
    svgContent += `</svg>`;
    this.grid.innerHTML = svgContent;
  }
  setSVGStyle(svgElement, style) {
    if (!svgElement) {
      return;
    }
    svgElement.style.width = `${style.width}px`;
    svgElement.style.height = `${style.height}px`;
    svgElement.style.left = `${style.left}px`;
    svgElement.style.top = `${style.top}px`;
  }
  /**
   * 获取相对滚动距离
   * @param realScroll
   * @param mod
   */
  getScrollDelta(realScroll, mod) {
    if (realScroll >= 0) {
      return realScroll % mod;
    }
    return mod - Math.abs(realScroll) % mod;
  }
};
BackgroundLayer.type = "WorkflowBackgroundLayer";
__decorateClass([
  (0, import_core.observeEntity)(import_core.PlaygroundConfigEntity)
], BackgroundLayer.prototype, "playgroundConfigEntity", 2);

// src/create-background-plugin.ts
var import_core2 = require("@flowgram.ai/core");
var createBackgroundPlugin = (0, import_core2.definePluginCreator)({
  onBind: (bindConfig, opts) => {
    bindConfig.bind(BackgroundConfig).toConstantValue(opts);
  },
  onInit: (ctx, opts) => {
    ctx.playground.registerLayer(BackgroundLayer, opts);
  }
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BackgroundConfig,
  BackgroundLayer,
  createBackgroundPlugin
});
//# sourceMappingURL=index.js.map